<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="William Schultz" />
  <meta name="author" content="William Schultz" />
  <title>Algorithms</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="../../style.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Algorithms</h1>
<p class="author">William Schultz</p>
<p class="author">William Schultz</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#graph-search"><span class="toc-section-number">1</span> Graph Search</a>
<ul>
<li><a href="#depth-first-search"><span class="toc-section-number">1.1</span> Depth-first search</a></li>
<li><a href="#breadth-first-search"><span class="toc-section-number">1.2</span> Breadth-first search</a></li>
</ul></li>
<li><a href="#other-problems"><span class="toc-section-number">2</span> Other Problems</a>
<ul>
<li><a href="#merge-k-sorted-lists">Merge k Sorted Lists</a></li>
<li><a href="#remove-duplicates-from-sorted-linked-list">Remove duplicates from sorted linked list</a></li>
<li><a href="#intersection-of-two-linked-lists">Intersection of two linked lists</a></li>
<li><a href="#reverse-linked-list">Reverse linked list</a></li>
<li><a href="#add-two-binary-strings">Add two binary strings</a></li>
<li><a href="#subsets-of-a-list">Subsets of a list</a></li>
</ul></li>
</ul>
</nav>
<section id="graph-search" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Graph Search</h1>
<p>Can think about general graph search algorithm as consisting of an <em>explored</em> set of nodes and a <em>frontier</em> set of nodes. The goal is to eventually have the explored set equal to all nodes in the graph. The frontier is a set of nodes that we maintain along the way. Initially, we set the frontier to the starting node of the graph. It is unexplored but currently on our list of nodes that need to be explored i.e. it is on the frontier. We then pick a new node from the frontier set, mark it as explored, and do any other work we might need to do, and then take all of its neighbors and add them to the frontier set.</p>
<section id="depth-first-search" class="level2" data-number="1.1">
<h2 data-number="1.1"><span class="header-section-number">1.1</span> Depth-first search</h2>
<p>Depth-first search searches deeper in a graph before searching broader. Can do a basic recursive or iterative implementation. Iterative implementation uses a stack to keep track of the frontier nodes, so that we explore deeper nodes first. We can also implement depth first search in a way that lets us recover paths to a node, by storing parent pointers as we go.</p>
</section>
<section id="breadth-first-search" class="level2" data-number="1.2">
<h2 data-number="1.2"><span class="header-section-number">1.2</span> Breadth-first search</h2>
<p>Breadth-first search searches all closer nodes before searching farther nodes i.e. it progresses in "levels" of depth. Not a standard way to implement it recursively, but can use a queue to keep track of the frontier nodes.</p>
</section>
</section>
<section id="other-problems" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Other Problems</h1>
<section id="merge-k-sorted-lists" class="level2 unnumbered">
<h2 class="unnumbered">Merge k Sorted Lists</h2>
<ul>
<li><p><strong>Problem</strong>: Given a set of <span class="math inline">\(k\)</span> linked lists, each which are individually sorted in ascending order, merge all <span class="math inline">\(k\)</span> lists into one sorted list.</p></li>
<li><p><strong>Solution Idea</strong>: The basic approach is to essentially just perform the <em>merge</em> step of merge-sort. That is, if we are given a set of already sorted lists, we can merge them all into one sorted lists by repeatedly popping the smallest element from the remaining, non-empty lists and appending it to the output list.</p></li>
<li><p><strong>Key Concepts</strong>:</p>
<ul>
<li><p><span style="color: blue"><em><strong>Mergesort Merging</strong></em></span></p></li>
<li><p><span style="color: blue"><em><strong>Linked List Manipulation</strong></em></span></p></li>
</ul>
<p>The essence of the solution is very straightforward as long as you know and understand the ideas behind mergesort i.e. knowing the core idea that you can merge a set of already sorted lists by incrementally choosing the smallest element from each.</p></li>
</ul>
</section>
<section id="remove-duplicates-from-sorted-linked-list" class="level2 unnumbered">
<h2 class="unnumbered">Remove duplicates from sorted linked list</h2>
<ul>
<li><p><strong>Problem</strong>: Given a sorted linked list, remove any duplicates from the list.</p></li>
<li><p><strong>Solution Idea</strong>: Iterate through the linked list, but at each node look ahead to see how many nodes in front of you contain an identical value to your own. Update your current “next" pointer to point to the first node after this block of identical nodes in front of you. Since the list is sorted, you know that any duplicates of the current value must be directly in front of you.</p></li>
<li><p><strong>Key Concepts</strong>:</p>
<ul>
<li><p><span style="color: blue"><em><strong>Linked List Traversal</strong></em></span></p></li>
<li><p><span style="color: blue"><em><strong>Linked List Deletion</strong></em></span></p></li>
<li><p><span style="color: blue"><em><strong>Duplicate Detection by Sorting</strong></em></span></p></li>
</ul>
<p>The underlying insight in the solution is to recognize that sorting a list can be used an easy mechanism for detecting duplicates. That is, in a sorted list, all duplicates of a particular item will always appear in contiguous “blocks". Once you recognize this fact, then implementing the solution mostly requires a standard application of linked list iteration and linked list item deletion. Namely, that to delete an item <span class="math inline">\(n_2\)</span> from a linked list that appears in a list as <span class="math inline">\(n1 \rightarrow n_2 \rightarrow n_3\)</span>, you simply update the “next" pointer of <span class="math inline">\(n_1\)</span> to point to <span class="math inline">\(n_3\)</span> instead of <span class="math inline">\(n_2\)</span>. Recall that a basic linked list node is a <span class="math inline">\(LinkedListNode(val, next)\)</span> structure, where <span class="math inline">\(val\)</span> is the value of that node, and <span class="math inline">\(next\)</span> is a pointer to the next item in the list.</p></li>
</ul>
</section>
<section id="intersection-of-two-linked-lists" class="level2 unnumbered">
<h2 class="unnumbered">Intersection of two linked lists</h2>
<ul>
<li><p><strong>Problem</strong>: Given two singly linked lists, return the node at which the two lists intersect. If they have no intersection, then return <em>null</em>.</p></li>
<li><p><strong>Solution Idea</strong>: This is similar to a <em>lowest common ancestor</em> problem. One approach is to walk backwards to the root from one of the lists and keep track of all nodes seen along the way. Then, walk backwards from the other list and check for the first node you hit that was already seen, and that node should be the intersection point. Note that this uses <span class="math inline">\(O(n)\)</span> space, if <span class="math inline">\(n\)</span> the upper bound on the size of the linked lists.</p>
<p>It’s also possible to do it without using any extra space by using a cleverer 2 pointer approach with a bit of counting. If we walk back to the root in both lists we can record the longer of the two. Then, from this we know the difference in length between the two lists, <span class="math inline">\(diff\)</span>. So, we can walk backwards by <span class="math inline">\(diff\)</span> pointers in the longer list, and then walk forwards from there in both lists at the same time, until we hit a point where both pointers are pointing to the same node.</p></li>
<li><p><strong>Key Concepts</strong>:</p>
<ul>
<li><p><span style="color: blue"><em><strong>Linked List Traversal</strong></em></span></p></li>
<li><p><span style="color: blue"><em><strong>Lowest Common Ancestor (?)</strong></em></span></p></li>
</ul></li>
</ul>
</section>
<section id="reverse-linked-list" class="level2 unnumbered">
<h2 class="unnumbered">Reverse linked list</h2>
<ul>
<li><p><strong>Problem</strong>: Given a singly linked list, reverse the list.</p></li>
<li><p><strong>Solution Idea</strong>: Iterate over the list and at each node, re-arrange the <em>next</em> pointer so it now points to the previous node rather than the next node. <span class="math display">\[\begin{aligned}
    None \rightarrow a \rightarrow b \rightarrow c\end{aligned}\]</span> If <span class="math inline">\(curr=a\)</span> and <span class="math inline">\(curr.next = b\)</span>, then to do the reversal we want to end up with <span class="math inline">\(a.next = None\)</span> and then step forward, ending up with <span class="math inline">\(curr=b\)</span>. So, at each step of the traversal, we keep track of hte previous item we looked at, so that we can reverse the pointer of the current node to point to it. We also need to save a reference to the next node before we update it.</p></li>
<li><p><strong>Key Concepts</strong>:</p>
<ul>
<li><p><span style="color: blue"><em><strong>Linked List Traversal</strong></em></span></p></li>
<li><p><span style="color: blue"><em><strong>Pointer Swapping (?)</strong></em></span></p></li>
</ul>
<p>Need to have a solid grasp of how to traverse a linked list, but also need to have good confidence in how to update points in a few steps (similar to how we swap variables), without overwriting the info we need to continue.</p></li>
</ul>
</section>
<section id="add-two-binary-strings" class="level2 unnumbered">
<h2 class="unnumbered">Add two binary strings</h2>
</section>
<section id="subsets-of-a-list" class="level2 unnumbered">
<h2 class="unnumbered">Subsets of a list</h2>
</section>
</section>
</body>
</html>
