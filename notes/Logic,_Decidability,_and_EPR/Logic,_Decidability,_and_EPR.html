<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="William Schultz" />
  <meta name="dcterms.date" content="2025-06-02" />
  <title>Notes on Logic, Decidability, EPR</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for citations */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
      margin-bottom: 0em;
    }
    .hanging-indent div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }  </style>
  <link rel="stylesheet" href="../../style.css" />
  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Notes on Logic, Decidability, EPR</h1>
<p class="author">William Schultz</p>
<p class="date">2025-06-02</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#propositional-logic" id="toc-propositional-logic"><span
class="toc-section-number">1</span> Propositional Logic</a>
<ul>
<li><a href="#decidability-and-complexity"
id="toc-decidability-and-complexity"><span
class="toc-section-number">1.1</span> Decidability and
Complexity</a></li>
<li><a href="#logical-consequence-and-theories"
id="toc-logical-consequence-and-theories"><span
class="toc-section-number">1.2</span> Logical Consequence and
Theories</a></li>
<li><a href="#deductive-systems-and-proofs"
id="toc-deductive-systems-and-proofs"><span
class="toc-section-number">1.3</span> Deductive Systems and
Proofs</a></li>
<li><a href="#resolution" id="toc-resolution"><span
class="toc-section-number">1.4</span> Resolution</a></li>
</ul></li>
<li><a href="#first-order-logic" id="toc-first-order-logic"><span
class="toc-section-number">2</span> First Order Logic</a>
<ul>
<li><a href="#interpretations" id="toc-interpretations"><span
class="toc-section-number">2.1</span> Interpretations</a></li>
<li><a href="#sec:fol-with-functions"
id="toc-sec:fol-with-functions"><span
class="toc-section-number">2.2</span> Functions</a></li>
<li><a href="#many-sorted-first-order-logic"
id="toc-many-sorted-first-order-logic"><span
class="toc-section-number">2.3</span> Many Sorted First Order
Logic</a></li>
<li><a href="#pcnf-and-clausal-form"
id="toc-pcnf-and-clausal-form"><span
class="toc-section-number">2.4</span> PCNF and Clausal Form</a>
<ul>
<li><a href="#skolemization" id="toc-skolemization"><span
class="toc-section-number">2.4.1</span> Skolemization</a></li>
</ul></li>
<li><a href="#sec:finite-models" id="toc-sec:finite-models"><span
class="toc-section-number">2.5</span> Finite Models</a></li>
<li><a href="#decidability" id="toc-decidability"><span
class="toc-section-number">2.6</span> Decidability</a>
<ul>
<li><a href="#decidable-classes" id="toc-decidable-classes"><span
class="toc-section-number">2.6.1</span> Decidable Classes</a></li>
<li><a href="#epr" id="toc-epr"><span
class="toc-section-number">2.6.2</span> EPR</a></li>
</ul></li>
</ul></li>
<li><a href="#bibliography" id="toc-bibliography">References</a></li>
</ul>
</nav>
<section id="propositional-logic" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span>
Propositional Logic</h1>
<p>We define <em>propositional logic</em> <span class="citation"
data-cites="2012benari">(<a href="#ref-2012benari"
role="doc-biblioref">Ben-Ari 2012</a>)</span> as a formal system
consisting of:</p>
<ul>
<li><p><span class="math inline">\({\mathcal{P}}\)</span>: a countably
infinite set of elements called <em>propositional symbols</em>. These
are alternately referred to as <em>propositional variables</em>,
<em>atomic propositions</em> or just <em>atoms</em>.</p></li>
<li><p><span class="math inline">\(\Omega\)</span>: set of logical
<em>operators</em> or <em>connectives</em>.</p></li>
</ul>
<p>For example, we traditionally have <span
class="math inline">\(\Omega=\{\wedge, \vee, \neg\}\)</span>. A
<em>formula</em> is defined as a sentence over propositional variables
conjoined via the operators of <span
class="math inline">\(\Omega\)</span>. We can define the the set of
syntactically valid formulas via a formal grammar. We let <span
class="math inline">\(\mathcal{F}\)</span> be the set of all such
formulas.</p>
<p>For a formula <span class="math inline">\(A \in \mathcal{F}\)</span>,
where <span class="math inline">\({\mathcal{P}}_A\)</span> is the set of
atoms that appear in <span class="math inline">\(A\)</span>, an
<em>interpretation</em> for <span class="math inline">\(A\)</span> is a
total function <span class="math display">\[\begin{aligned}
    \mathcal{I}_A : {\mathcal{P}}_A \rightarrow \{True,False\}
\end{aligned}\]</span> that assigns one of the <em>truth values</em>,
<em>True</em> or <em>False</em>, to every atom in <span
class="math inline">\({\mathcal{P}}_A\)</span>. In other words, it’s
just an assignment of boolean values to propositional variables. The
truth value of a formula <span class="math inline">\(A\)</span>
<em>under</em> an interpretation <span
class="math inline">\(\mathcal{I}_A\)</span>, denoted <span
class="math inline">\(v_{\mathcal{I}_{A}}(A)\)</span>, is defined in the
standard way. That is, just plug in the values for each propositional
variable as given by the interpretation function <span
class="math inline">\(\mathcal{I}_A\)</span> and then evaluate the
formula according to the semantics of the standard logical connectives.
Note that although this is the “classical” notion of intepretation for
propositional logic, we could have a more general notion of
intepretation that allows for an intepretation function <span
class="math inline">\(\mathcal{I} : \mathcal{P}_A \rightarrow D\)</span>
that maps propositional symbols to some arbitrary domain of values. The
logical connectives contained in <span
class="math inline">\(\Omega\)</span> must then also be given
appropriate semantics in accordance. For example, three-valued,
many-valued logic systems.</p>
<p>For a formula <span class="math inline">\(A \in \mathcal{F}\)</span>
we have the following definitions:</p>
<ul>
<li><p><span class="math inline">\(A\)</span> is <em>satisfiable</em>
iff <span class="math inline">\(v_{\mathcal{I}_{A}}(A) = True\)</span>
for <em>some</em> intepretation <span
class="math inline">\(\mathcal{I}\)</span>. A satisfying intepretation
is called a <em>model</em> for <span
class="math inline">\(A\)</span>.</p></li>
<li><p><span class="math inline">\(A\)</span> is <em>valid</em> iff
<span class="math inline">\(v_\mathcal{I}(A)=True\)</span> for
<em>all</em> intepretations <span
class="math inline">\(\mathcal{I}\)</span>.</p></li>
<li><p><span class="math inline">\(A\)</span> is <em>unsatisfiable</em>
iff it is not satisfiable i.e. if <span
class="math inline">\(v_\mathcal{I}(A)=False\)</span> for <em>all</em>
interpretations <span
class="math inline">\(\mathcal{I}\)</span>.</p></li>
</ul>
<p>Determining the validity of a propositional formula <span
class="math inline">\(\phi \in \mathcal{F}\)</span> (i.e. checking if it
is a tautology) can be done by checking the unsatisfiability of <span
class="math inline">\(\neg \phi\)</span> i.e. <span
class="math display">\[\begin{aligned}
    \phi \text{ is valid} \iff UNSAT(\neg \phi)
\end{aligned}\]</span> That is, we check if there are any
interpretations that violate <span class="math inline">\(\phi\)</span>.
If there are none, then <span class="math inline">\(\phi\)</span> must
be true under all interpretations i.e. <span
class="math inline">\(\phi\)</span> is a tautology.</p>
<section id="decidability-and-complexity" class="level2"
data-number="1.1">
<h2 data-number="1.1"><span class="header-section-number">1.1</span>
Decidability and Complexity</h2>
<p>Determining any of the above properties for a propositional formula
is a decidable problem, since we can easily enumerate the finite
(exponentially many) number of possible intepretations for a formula to
determine whether it is satisfiable/valid/unsatisfiable. The
satisfiability problem for propositional formulas is known as the SAT
problem, and is NP-complete. In some special cases satisfiability can be
solved in polynomial time e.g. 2-SAT (where CNF clauses contain 2
variables) is in P, as is HORNSAT (where clauses have at most one
non-negated literal). The 3-SAT problem, however, is NP-complete. The
problem of checking validity/tautology of propositional formulas is
co-NP-complete.</p>
</section>
<section id="logical-consequence-and-theories" class="level2"
data-number="1.2">
<h2 data-number="1.2"><span class="header-section-number">1.2</span>
Logical Consequence and Theories</h2>
<p>For a set of formulas <span
class="math inline">\(U=\{A_1,\dots\}\)</span>, a <em>model</em> of
<span class="math inline">\(U\)</span> is an interpretation <span
class="math inline">\(\mathcal{I}\)</span> such that <span
class="math inline">\(v_\mathcal{I}(A_i)=True\)</span> for all <span
class="math inline">\(A_i \in U\)</span>. For a given formula <span
class="math inline">\(A\)</span>, we say that <span
class="math inline">\(A\)</span> is a <em>logical consequence of U</em>,
denoted <span class="math inline">\(U \vDash A\)</span>, iff every model
of <span class="math inline">\(U\)</span> is a model of <span
class="math inline">\(A\)</span>. That is, for any interpretation that
is a model of <span class="math inline">\(U\)</span>, it is also a model
of <span class="math inline">\(A\)</span>.</p>
<p>Let <span class="math inline">\(U\)</span> be a set of formulas. We
say that <span class="math inline">\(U\)</span> is <em>closed under
logical consequence</em> iff for all formulas <span
class="math inline">\(A\)</span>, if <span class="math inline">\(U
\vDash A\)</span>, then <span class="math inline">\(A \in U\)</span>. A
set of formulas that is closed under logical consequence is called a
<em>theory</em>. The elements of <span class="math inline">\(U\)</span>
are <em>theorems</em>. Theories are typically constructed by selecting a
set of formulas called <em>axioms</em> and deducing their logical
consequences. For a given set of formulas <span
class="math inline">\(U\)</span>, we say that <span
class="math inline">\(U\)</span> is <em>axiomatizable</em> iff there
exists a set of formulas <span class="math inline">\(X\)</span> such
that <span class="math inline">\(U = \{A \mid X \vDash A\}\)</span>.
That is, there exists a set of formulas <span
class="math inline">\(X\)</span> such that every formula in <span
class="math inline">\(U\)</span> can be deduced as a logical consequence
of the formulas in <span class="math inline">\(X\)</span>. The set of
formulas <span class="math inline">\(X\)</span> are the <em>axioms</em>
of <span class="math inline">\(U\)</span>. If <span
class="math inline">\(X\)</span> is finite, then <span
class="math inline">\(U\)</span> is said to be <em>finitely
axiomatizable</em>.</p>
</section>
<section id="deductive-systems-and-proofs" class="level2"
data-number="1.3">
<h2 data-number="1.3"><span class="header-section-number">1.3</span>
Deductive Systems and Proofs</h2>
<p>Using a purely semantical approach to determining the validity of
formulas in propositional logic can have various drawbacks. For example,
not all logics have decision procedures like propositional logic. Thus,
we can use an alternate, deductive approach.</p>
<p>A <em>deductive system</em> is a set of formulas called
<em>axioms</em> and a set of <em>rules of inference</em>. A
<em>proof</em> in a deductive system is a sequence of formulas <span
class="math inline">\(S = \{A_1,\dots,A_n\}\)</span> such that each
formula <span class="math inline">\(A_i\)</span> is either an axiom or
it can be inferred from previous formulas of the sequence <span
class="math inline">\(A_{j_1},\dots,A_{j_k}\)</span>, using a rule of
inference. For <span class="math inline">\(A_n\)</span>, the last
formula in the sequence,we say that <span
class="math inline">\(A_n\)</span> is a <em>theorem</em>, the sequence
<span class="math inline">\(S\)</span> is a <em>proof</em> of <span
class="math inline">\(A_n\)</span>, and <span
class="math inline">\(A_n\)</span> is <em>provable</em>, denoted <span
class="math inline">\(\vdash A_n\)</span>. Note that even if there is no
decision procedure to discover a proof, it can be mechanically
<em>checked</em> i.e. using a syntax based approach to check that each
applied inference rule is valid.</p>
<p>Proving soundness and completeness of a deductive system <span
class="math inline">\(\mathcal{D}\)</span> means showing that for any
formula <span class="math inline">\(A\)</span>, <span
class="math display">\[\begin{aligned}
    \vDash A \iff \vdash A  
\end{aligned}\]</span> for <span
class="math inline">\(\mathcal{D}\)</span>. That is, if <span
class="math inline">\(A\)</span> is valid (in a semantical sense), then
<span class="math inline">\(A\)</span> is provable in <span
class="math inline">\(\mathcal{D}\)</span>, and vice versa. A deductive
system <span class="math inline">\(\mathcal{D}\)</span> is sound if any
provable statement in <span class="math inline">\(\mathcal{D}\)</span>
is a true statement i.e. if <span class="math inline">\(\vdash
A\)</span> then <span class="math inline">\(\vDash A\)</span>.</p>
</section>
<section id="resolution" class="level2" data-number="1.4">
<h2 data-number="1.4"><span class="header-section-number">1.4</span>
Resolution</h2>
<p>The method of <em>resolution</em> is an efficient method for
searching for a proof. More precisely, it is a decision procedure for
unsatisfiability in propositional logic.</p>
<p>Assume we have a propositional formula given in <em>clausal
form</em>, which is basically just conjunctive normal form (CNF) where
each clause is viewed as a set of literals. This representation doesn’t
discard any essential information from the CNF representation, since a
CNF formula is a conjunction of clauses, and the order doesn’t matter
for either the overall conjunction or the disjunctions within each
clause. For example, the following formula in CNF <span
class="math display">\[\begin{aligned}
    (a \vee b) \wedge (b \vee \neg c \vee b)
\end{aligned}\]</span> is written in clausal form as <span
class="math display">\[\begin{aligned}
    \{\{a,b\},\{b,\neg c\}\}
\end{aligned}\]</span> A clause is <em>trivial</em> if it contains a
pair of clashing literals i.e. if it contains both a literal and its
negation. That is, <span class="math inline">\((x \vee \neg x) \iff
True\)</span>, so <span class="math inline">\(\{x, \neg x\}\)</span> can
always be removed from a clause without changing the truth value of the
clause. We consider the empty clause to be unsatisfiable, and denote it
as <span class="math inline">\(\square\)</span>. We consider the empty
set of clauses, <span class="math inline">\(\emptyset\)</span>. to be
valid.</p>
<p>Now, we say that two clauses <span
class="math inline">\(C_1,C_2\)</span> are <em>clashing</em> if there
are literals <span class="math inline">\(l \in C_1\)</span> and <span
class="math inline">\(l^c \in C_2\)</span>, where <span
class="math inline">\(l^c\)</span> is the complement of the literal
<span class="math inline">\(l\)</span> (i.e. if <span
class="math inline">\(l=p\)</span>, then <span
class="math inline">\(l^c=\bar{p}\)</span>). We say that <span
class="math inline">\(C_1,C_2\)</span> <em>clash on</em> the pair of
literals <span class="math inline">\(l,l^c\)</span>. We define the
<em>resolvent</em> of <span class="math inline">\(C_1\)</span> and <span
class="math inline">\(C_2\)</span> as the clause <span
class="math display">\[\begin{aligned}
Res(C_1,C_2) = (C_1 - \{l\}) \cup (C_2 - \{l^c\})    
\end{aligned}\]</span> and <span class="math inline">\(C_1\)</span> and
<span class="math inline">\(C_2\)</span> are the <em>parent clauses</em>
of <span class="math inline">\(C\)</span>. That is, the resolvent <span
class="math inline">\(C\)</span> is produced by removing <span
class="math inline">\(l\)</span> and <span
class="math inline">\(l^c\)</span> from their respective clauses <span
class="math inline">\(C_1,C_2\)</span>, and then taking the union of the
two resulting clauses.</p>
<p>For example, the clauses <span
class="math inline">\(C_1=ab\bar{c}\)</span> and <span
class="math inline">\(C_2=bc\bar{e}\)</span> clash on the pair of
literals <span class="math inline">\(c\)</span> and <span
class="math inline">\(\bar{c}\)</span>. The resolvent is <span
class="math display">\[\begin{aligned}
    Res(C_1,C_2) &amp;= (ab\bar{c} - \{\bar{c}\}) \cup (bc\bar{e} -
\{c\})\\
    &amp;=ab \cup b\bar{e}\\
    &amp;=ab\bar{e}\\
    &amp;=\{a,b,\bar{e}\}
\end{aligned}\]</span></p>
<p>Note that resolution is only performed if the pair of clauses clash
on <em>exactly</em> one pair of complementary literals. The important
thing to note is that the resolvent <span
class="math inline">\(C\)</span> is satisfiable iff the parent clauses
<span class="math inline">\(C_1\)</span> and <span
class="math inline">\(C_2\)</span> are both satisfiable. Thus, the
resolution procedure then basically proceeds by taking in a set of
clauses <span class="math inline">\(S\)</span> and repeatedly applying
this resolution rule. That is</p>
<ol>
<li><p>Choose a pair of clashing clauses <span
class="math inline">\(\{C_1,C_2\} \subseteq S_i\)</span> that has not
been chosen before.</p></li>
<li><p>Compute <span
class="math inline">\(Res(C_1,C_2)\)</span>.</p></li>
<li><p>If <span class="math inline">\(C\)</span> is not a trivial
clause, let <span class="math inline">\(S_{i+1}=S_i \cup \{C\}\)</span>.
Otherwise <span class="math inline">\(S_{i+1}=S_i\)</span>.</p></li>
<li><p>Terminate the procedure if either:</p>
<ul>
<li><p><span class="math inline">\(C=\square\)</span></p></li>
<li><p>All pairs of clashing clauses have been resolved.</p></li>
</ul></li>
</ol>
<p>See Figure <a href="#fig:resolution-refutation-tree"
data-reference-type="ref"
data-reference="fig:resolution-refutation-tree">1</a> for an example of
a resolution proof for the clause set <span
class="math inline">\(S=\{p,\bar{p}q, \bar{r}, \bar{p}
\bar{q}r\}\)</span> where the rule applications are represented as a
tree, leading to the unsatisfiable clause.</p>
<figure id="fig:resolution-refutation-tree">
<p><img src="figures/refutation-example.png" alt="image" /> <span
id="fig:resolution-refutation-tree"
label="fig:resolution-refutation-tree"></span></p>
</figure>
<p>Note that an alternative way to state the resolution inference rule
is in terms of implication, where <span class="math inline">\(c\)</span>
is a literal. Note that the following variants of the resolution rule
are all equivalent, some of which make the intuition behind the rule a
bit clearer (where the upper formulas represent the premises and lower
represents the conclusion):</p>
<div class="center">
<table>
<thead>
<tr>
<th style="text-align: center;"><span class="math inline">\(A \vee
c\)</span></th>
<th style="text-align: center;"><span class="math inline">\(B \vee \neg
c\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" style="text-align: center;"><span
class="math inline">\(A \vee B\)</span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;"><span class="math inline">\(\neg A
\Rightarrow c\)</span></th>
<th style="text-align: center;"><span class="math inline">\(c
\Rightarrow B\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" style="text-align: center;"><span
class="math inline">\(\neg A \Rightarrow B\)</span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;"><span class="math inline">\(\neg c
\Rightarrow A\)</span></th>
<th style="text-align: center;"><span class="math inline">\(c
\Rightarrow B\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" style="text-align: center;"><span
class="math inline">\(A \vee B\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>For example, in the second variant, the conclusion <span
class="math inline">\(\neg A \Rightarrow B\)</span> is equivalent to
<span class="math inline">\(A \vee B\)</span>, and also note the
“case-splitting” aspect of the third statement i.e. we know that either
<span class="math inline">\(c\)</span> or <span
class="math inline">\(\neg c\)</span> must hold, and so if we know that
<span class="math inline">\(\neg c \Rightarrow A\)</span> and <span
class="math inline">\(c \Rightarrow B\)</span>, then <span
class="math inline">\(A\)</span> or <span
class="math inline">\(B\)</span> must be true.</p>
</section>
</section>
<section id="first-order-logic" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> First
Order Logic</h1>
<p><em>First order logic</em> extends propositional logic to include
quantification over some specified domain, in addition to a more general
notion of <em>interpretation</em> for a given formula.</p>
<p>In order to define the structure of first order formulas, we first
define the following:</p>
<ul>
<li><p><span class="math inline">\(\mathcal{P}\)</span>: a countable set
of <em>predicate symbols</em> (alternately <em>relation
symbols</em>)</p></li>
<li><p><span class="math inline">\(\mathcal{A}\)</span>: a countable set
of <em>constant symbols</em>.</p></li>
<li><p><span class="math inline">\(\mathcal{V}\)</span>: a countable set
of <em>variables</em>.</p></li>
</ul>
<p>The sets of predicate and constant symbols, <span
class="math inline">\((\mathcal{P}, \mathcal{A})\)</span>, are also
collectively referred to as the <em>signature</em> of a first order
logic. Each predicate symbol <span class="math inline">\(p^n \in
\mathcal{P}\)</span> has an arity, which is the number <span
class="math inline">\(n \geq 1\)</span> of <em>arguments</em> that it
takes. Note that these predicate symbols are merely syntactic objects
i.e. they are <em>not</em> relations, semantically. Rather, they are
given semantics under an <em>interpretation</em> (described below),
which assigns a relation of the proper arity to each predicate symbol.
Note that we can optionally augment the above list to include
<em>function symbols</em>, which also have a specified arity similar to
<em>predicate symbols</em>, but it is not necessary to give a basic
definition of first order logic. This extension to function symbols is
also discussed below.</p>
<p>An <em>atomic formula</em> of first order logic is an <span
class="math inline">\(n\)</span>-ary predicate followed by a list of
<span class="math inline">\(n\)</span> arguments <span
class="math inline">\(p(t_1,\dots,t_n)\)</span>, where each argument
<span class="math inline">\(t_i\)</span> is either a variable or a
constant. A <em>formula</em> of first order logic is defined as strings
generated by the following grammar: <span
class="math display">\[\begin{aligned}
    &amp;argument&amp; &amp;::= x \qquad &amp;\text{for any } x\in
\mathcal{V}\\
    &amp;argument&amp; &amp;::= a \qquad &amp;\text{for any } a\in
\mathcal{A}\\
    &amp;argument\_list&amp; &amp;::= argument\\
    &amp;argument\_list&amp; &amp;::= argument,argument\_list\\
    &amp;atomic\_formula&amp; &amp;::= p(argument\_list) \qquad
&amp;\text{for any $n$-ary } p\in \mathcal{P}\\
    \\
    &amp;formula&amp; &amp;::= atomic\_formula\\
    &amp;formula&amp; &amp;::= \neg \, formula\\
    &amp;formula&amp; &amp;::= formula \vee formula\\
    &amp;formula&amp; &amp;::= \exists x \, formula \qquad
&amp;\text{for any } x \in \mathcal{V}\\
    &amp;formula&amp; &amp;::= \forall x \, formula \qquad
&amp;\text{for any } x \in \mathcal{V}
\end{aligned}\]</span> Note that for a formula <span
class="math inline">\(A\)</span>, an occurrence of a variable <span
class="math inline">\(x\)</span> in <span
class="math inline">\(A\)</span> is a <em>free variable</em> of <span
class="math inline">\(A\)</span> iff <span
class="math inline">\(x\)</span> is not within the scope of a quantified
variable. A variable which is not free is <em>bound</em>. If a formula
has no free variables, it is <em>closed</em>.</p>
<section id="interpretations" class="level2" data-number="2.1">
<h2 data-number="2.1"><span class="header-section-number">2.1</span>
Interpretations</h2>
<p>In propositional logic, an interpretation is a mapping from atomic
propositions (i.e. propositional variables) to truth values (i.e. <span
class="math inline">\(\{True, False\}\)</span>). In first order logic,
the analogous concept is a mapping from atomic formulas to truth values.
The atomic formulas of first order logic, however, contain variables and
constants that must be assigned elements of some domain. In
propositional logic, each atomic proposition is assumed to be
boolean-valued, so this is not a concern. That is, the “domain” of each
propositional variable is implicitly assumed to be the truth values
<span class="math inline">\(\{True,False\}\)</span>. In first order
logic, this is generalized by allowing variables to range over specified
domains.</p>
<p>Let <span class="math inline">\(A\)</span> be a formula of first
order logic where <span class="math inline">\(\{p_1,\dots,p_m\}\)</span>
are all the predicates appearing in <span
class="math inline">\(A\)</span> and <span
class="math inline">\(\{a_1,\dots,a_k\}\)</span> are all the constants
appearing in <span class="math inline">\(A\)</span>. An
<em>interpretation</em> <span
class="math inline">\(\mathcal{I}_A\)</span> for a formula <span
class="math inline">\(A\)</span> is a triple consisting of the
following:</p>
<ul>
<li><p><span class="math inline">\(D\)</span>: a <em>non-empty</em> set
called the <em>domain</em></p></li>
<li><p><span class="math inline">\(\{R_1,\dots, R_m\}\)</span>: a set of
relations on <span class="math inline">\(D\)</span>, where <span
class="math inline">\(R_i\)</span> is an <span
class="math inline">\(n_i\)</span>-ary relation on <span
class="math inline">\(D\)</span> (that is, <span
class="math inline">\(R_i \subseteq D^{n_i}\)</span>) assigned to the
<span class="math inline">\(n_i\)</span>-ary predicate symbol <span
class="math inline">\(p_i\)</span>.</p></li>
<li><p><span class="math inline">\(\{d_1,\dots,d_k\}\)</span>: a set of
constant values, where <span class="math inline">\(d_i \in D\)</span> is
assigned to the constant <span
class="math inline">\(a_i\)</span>.</p></li>
</ul>
<p>In other words, an interpretation defines a “domain of discourse”
<span class="math inline">\(D\)</span>, along with a concrete assignment
of relations to each predicate symbol <span class="math inline">\(p \in
\mathcal{P}\)</span> and values from the domain to each constant <span
class="math inline">\(a \in \mathcal{A}\)</span>.</p>
<p>For example, if we have <span class="math display">\[\begin{aligned}
    \mathcal{P} &amp;= \{p\}\\
    \mathcal{A} &amp;= \{a\}\\
    \mathcal{V} &amp;= \{x\}
\end{aligned}\]</span> then a first order formula may look like: <span
class="math display">\[\begin{aligned}
    \forall x p(a,x)
\end{aligned}\]</span> which might contain the following various
interpretations: <span class="math display">\[\begin{aligned}
    \mathcal{I}_1 = (\mathbb{N},\{\leq\},\{0\})\qquad
    \mathcal{I}_2 = (\mathbb{N},\{\leq\},\{1\})\qquad
    \mathcal{I}_3 = (\mathbb{Z},\{\leq\},\{0\})
\end{aligned}\]</span> where the domain is either the natural numbers,
<span class="math inline">\(\mathbb{N}\)</span>, or the integers, <span
class="math inline">\(\mathbb{Z}\)</span>, and the binary relation <span
class="math inline">\(\leq\)</span> is assigned to the binary predicate
symbol <span class="math inline">\(p\)</span>, and either 0 or 1
assigned to the constant <span class="math inline">\(a\)</span>. We
could also have an interpretation over strings e.g. <span
class="math display">\[\begin{aligned}
    \mathcal{I}_4 = (Str, \{isPrefix\}, \{``s&quot;\})
\end{aligned}\]</span> where <span class="math inline">\(Str\)</span>
represents the set of all strings, <span
class="math inline">\(isPrefix\)</span> is the binary relation
determining if one string is a prefix of another, and “s” is a single
character string. This illustrates that the same first order logic
formulas can be “imbued” (i.e. <em>interpreted</em>) with various
semantics. Furthermore, for an interpretation <span
class="math inline">\(\mathcal{I}_A\)</span> and formula <span
class="math inline">\(A\)</span>, an <em>assignment</em> <span
class="math inline">\(\sigma_{\mathcal{I}_A} : \mathcal{V} \rightarrow
D\)</span> is a function that maps every free variable <span
class="math inline">\(v \in \mathcal{V}\)</span> to an element <span
class="math inline">\(d \in D\)</span>, the domain of <span
class="math inline">\(\mathcal{I}_A\)</span>.</p>
<p>For a closed formula <span class="math inline">\(A\)</span> (no free
variables), the <em>truth value</em> of <span
class="math inline">\(A\)</span> under <span
class="math inline">\(\mathcal{I}_A\)</span>, denoted <span
class="math inline">\(v_{\mathcal{I}_A}(A)\)</span>, is given by
“evaluating” the formula in the standard way. That is, evaluating the
inner, unquantified formula over each element in the domain, for each
quantified variable, plugging into the predicates of the formula and
evaluating. We can define these evaluation semantics formally but it is
mostly straightforward. For example, the truth value of the closed
formula <span class="math display">\[\begin{aligned}
    \forall x \, p(a,x)
\end{aligned}\]</span> under the interpretation <span
class="math display">\[\begin{aligned}
    \mathcal{I}_1 = (\{0,1\},\{\leq\},\{0\})\qquad
\end{aligned}\]</span> evaluates to <span
class="math inline">\(True\)</span> iff <span class="math inline">\(0
\leq x\)</span> for all <span class="math inline">\(x \in
\{0,1\}\)</span>.</p>
<p>Now we define the following for a closed formula <span
class="math inline">\(A\)</span> of first order logic:</p>
<ul>
<li><p><span class="math inline">\(A\)</span> is <em>true</em> in <span
class="math inline">\(\mathcal{I}\)</span> (alternately, <span
class="math inline">\(\mathcal{I}\)</span> is a <em>model</em> for <span
class="math inline">\(A\)</span>) iff <span
class="math inline">\(v_\mathcal{I}(A)=True\)</span>. We denote this as
<span class="math inline">\(\mathcal{I}\vDash A\)</span>.</p></li>
<li><p><span class="math inline">\(A\)</span> is <em>valid</em> if for
all interpretations <span class="math inline">\(\mathcal{I}\)</span>,
<span class="math inline">\(\mathcal{I} \vDash A\)</span></p></li>
<li><p><span class="math inline">\(A\)</span> is <em>satisfiable</em> if
for some interpretation <span
class="math inline">\(\mathcal{I}\)</span>, <span
class="math inline">\(\mathcal{I} \vDash A\)</span></p></li>
<li><p><span class="math inline">\(A\)</span> is <em>unsatisfiable</em>
if it is not satisfiable.</p></li>
</ul>
<p>Note that these definitions of validity/satisfiability are a bit more
involved than in the case of propositional logic. We must consider a
formula under <em>all possible interpretations</em> in order to consider
validity. For satisfiability, we may only need to find one adequate
interpretation, though we may need to consider/search through many
possible interpretations.</p>
</section>
<section id="sec:fol-with-functions" class="level2" data-number="2.2">
<h2 data-number="2.2"><span class="header-section-number">2.2</span>
Functions</h2>
<p>Our definition above for defining the structure of first order
formulas did not allow for the inclusion of functions i.e. we only
allowed predicate symbols. We can generalize this to allow for functions
in our first order formulas. Adding functions basically augments the set
<span class="math inline">\((\mathcal{P}, \mathcal{A},
\mathcal{V})\)</span> of <em>predicate symbols</em>, <em>constant
symbols</em>, and <em>variables</em>, with a set <span
class="math inline">\(\mathcal{F}\)</span> of <em>function symbols</em>,
each with a specified arity, as with predicate symbols. The notion of an
<em>interpretation</em> of a formula is thus also augmented, to become a
4-tuple <span class="math display">\[\begin{aligned}
    \mathcal{I} = (D, \{R_1,\dots, R_k\},  \{F_1^{n_1},\dots,
F_l^{n_l}\}, \{d_1,\dots,d_k\})
\end{aligned}\]</span> where each <span
class="math inline">\(F_j^{n_j}\)</span> is an <span
class="math inline">\(n_j\)</span>-ary function on <span
class="math inline">\(D\)</span> that is assigned to the function symbol
<span class="math inline">\(f_j^{n_j}\)</span>, with the rest of the
semantics essentially unchanged. The grammar of formulas is also updated
to account for functions, which produce a value in the domain <span
class="math inline">\(D\)</span>, rather than a truth value, as
predicates do. Note that if we allow for function symbols, then we can
simply view constants as functions of arity 0.</p>
</section>
<section id="many-sorted-first-order-logic" class="level2"
data-number="2.3">
<h2 data-number="2.3"><span class="header-section-number">2.3</span>
Many Sorted First Order Logic</h2>
<p>In standard first order logic, interpretations are over a single
domain <span class="math inline">\(D\)</span>. Many-sorted logic
generalizes this to allow for multiple domains, referred to as
<em>sorts</em> <span class="citation"
data-cites="2014manysortedlogic">(<a href="#ref-2014manysortedlogic"
role="doc-biblioref">Vaananen 2014</a>)</span>. That is, a signature is
augmented to include a set of <em>sorts</em>, where the arity of each
predicate, constant, and/or function symbol now also includes the sort
of each of its arguments. An interpretation consists of a triple <span
class="math display">\[\begin{aligned}
    (\{D_1,\dots,D_n\}, \{R_1,\dots, R_m\},\{d_1,\dots,d_k\})
\end{aligned}\]</span> where <span
class="math inline">\(\{D_1,\dots,D_n\}\)</span> are domains assigned to
each <em>sort</em>.</p>
<p>There is also a notion of <em>stratification</em> of sorts i.e. a
total order on all sorts. This is made use of in Ivy <span
class="citation" data-cites="2020ivymultimodal">(<a
href="#ref-2020ivymultimodal" role="doc-biblioref">McMillan and Padon
2020</a>)</span> and also discussed in prior work <span class="citation"
data-cites="2007decidablefragmentsmanysorted 2009completeinstant">(<a
href="#ref-2007decidablefragmentsmanysorted" role="doc-biblioref">Abadi,
Rabinovich, and Sagiv 2007</a>; <a href="#ref-2009completeinstant"
role="doc-biblioref">Ge and Moura 2009</a>)</span>. Sorted first order
logic is the basic formalism used, for example, in the original Ivy
paper <span class="citation" data-cites="padon2016ivy">(<a
href="#ref-padon2016ivy" role="doc-biblioref">Padon et al.
2016</a>)</span> that described their modeling language. It is also used
as the encoding for TLA+ in TLAPS <span class="citation"
data-cites="2016merzmanysorted">(<a href="#ref-2016merzmanysorted"
role="doc-biblioref">Merz and Vanzetto 2016</a>)</span>.</p>
</section>
<section id="pcnf-and-clausal-form" class="level2" data-number="2.4">
<h2 data-number="2.4"><span class="header-section-number">2.4</span>
PCNF and Clausal Form</h2>
<p>In propositional logic, a formula is in conjunctive normal form (CNF)
if it is a conjunct of clauses (where a clause is a disjunction of
literals). A notational variant of CNF is <em>clausal form</em> i.e. a
formula is represented as a set of clauses, where each clause is a set
of literals.</p>
<p>We generalize CNF to first order logic by defining a normal form that
accounts for quantifiers. We say that a formula is in <em>PCNF</em>
(<em>prenex conjunctive normal form</em>) iff it is of the form: <span
class="math display">\[\begin{aligned}
    Q_1 x_1 \dots Q_n x_n \, M
\end{aligned}\]</span> where <span class="math inline">\(Q_i\)</span>
are quantifiers and <span class="math inline">\(M\)</span> is a
quantifier-free formula in CNF (conjunctive normal form). The sequence
<span class="math inline">\(Q_1 x_1\dots Q_n x_n\)</span> is the
<em>prefix</em> and <span class="math inline">\(M\)</span> is the
<em>matrix</em>. Also, let <span class="math inline">\(A\)</span> be a
closed formula in PCNF whose prefix consists only of universal
quantifiers. The <em>clausal form</em> of <span
class="math inline">\(A\)</span> consists of the matrix of <span
class="math inline">\(A\)</span> written as a set of clauses.</p>
<section id="skolemization" class="level3" data-number="2.4.1">
<h3 data-number="2.4.1"><span class="header-section-number">2.4.1</span>
Skolemization</h3>
<p>In propositional logic, every formula can be translated to an
equivalent one in CNF, but this is not the case in first order logic. We
can, however, transform a formula in first order logic into one in
clausal form (i.e. one with only universal quantifiers) without
modifying its satisfiability. That is, formally, if <span
class="math inline">\(A\)</span> is a closed formula, then there exists
a formula <span class="math inline">\(A&#39;\)</span> in clausal form
such that <span class="math inline">\(A \approx A&#39;\)</span>, where
<span class="math inline">\(\approx\)</span> denotes the
equisatisfiability relation. That is, <span
class="math inline">\(A\)</span> is satisfiable iff <span
class="math inline">\(A&#39;\)</span> is. Note that this does not mean
that <span class="math inline">\(A\)</span> and <span
class="math inline">\(A&#39;\)</span> are logically equivalent. The
process of transforming <span class="math inline">\(A\)</span> into such
a form <span class="math inline">\(A&#39;\)</span> is referred to as
<em>Skolemization</em>. That is, a formula is in <em>Skolem normal
form</em> if it is in prenex normal form with only universal
quantifiers.</p>
<p>It is straightforward to first transform <span
class="math inline">\(A\)</span> into a logically equivalent formula in
PCNF. The removal of existential quantifiers is the main challenge. The
basic idea of Skolemization can be illustrated with a sample formula:
<span class="math display">\[\begin{aligned}
    \forall x \exists y : p(x,y)
\end{aligned}\]</span> Intuitively, we think of reading the quantifiers
as “for all <span class="math inline">\(x\)</span>, find a <span
class="math inline">\(y\)</span> associated with <span
class="math inline">\(x\)</span> such that the predicate <span
class="math inline">\(p\)</span> is true”. This basically matches the
intuitive concept of a function. That is, we want a function <span
class="math inline">\(f\)</span> such that <span
class="math inline">\(y=f(x)\)</span>. So, the existential quantifier
can be removed, giving <span class="math inline">\(A&#39; = \forall x :
p(x,f(x))\)</span>.</p>
</section>
</section>
<section id="sec:finite-models" class="level2" data-number="2.5">
<h2 data-number="2.5"><span class="header-section-number">2.5</span>
Finite Models</h2>
<p>We say that a set of formulas <span
class="math inline">\(U=\{A_1,\dots\}\)</span> is <em>satisfiable</em>
iff there exists an interpretation <span
class="math inline">\(\mathcal{I}_U\)</span> such that <span
class="math inline">\(v_{\mathcal{I}_U}(A_i)=True\)</span> for all <span
class="math inline">\(i\)</span>. The satisfying interpretation is a
<em>model</em> for <span class="math inline">\(U\)</span>.</p>
<p>A set of formulas <span class="math inline">\(U\)</span> has the
<em>finite model property</em> iff: <span
class="math inline">\(U\)</span> is satisfiable iff it is satisfiable in
an interpretation whose domain is a finite set. As one example, let
<span class="math inline">\(U\)</span> be the set of pure formulas (no
function symbols) of the form <span
class="math display">\[\begin{aligned}
    \exists x_1 \dots \exists x_m \forall y_1 \dots \forall y_n \,
A(x_1,\dots,x_m,y_1,\dots,y_n)
\end{aligned}\]</span> where <span class="math inline">\(A\)</span> is
quantifier free. Then <span class="math inline">\(U\)</span> has the
finite model property.</p>
<p>Another interesting fact is one due to Löwenheim-Skolem, which says
that if a formula of first order logic is satisfiable, then it is
satisfiable in a countable domain (Theorem 12.10 in <span
class="citation" data-cites="2012benari">(<a href="#ref-2012benari"
role="doc-biblioref">Ben-Ari 2012</a>)</span>). Thus, countable domains
(e.g. the natural numbers) are sufficient for interpretation of first
order logic.</p>
</section>
<section id="decidability" class="level2" data-number="2.6">
<h2 data-number="2.6"><span class="header-section-number">2.6</span>
Decidability</h2>
<p>Checking validity of a formula in first order logic is undecidable.
Even under particular, fixed interpretations, checking validity may be
undecidable. For example, Peano arithmetic, which consists of a single
constant symbol <span class="math inline">\(0\)</span>, a function
symbol <span class="math inline">\(s\)</span> representing the successor
function, and two binary function symbols, <span
class="math inline">\(+\)</span> and <span
class="math inline">\(*\)</span>, is undecidable. In addition, a theorem
of Trakhtenbrot gives a further refinement. It states that even if we
consider first order logic over only the class of finite models, then
validity and satisfiability are both still undecidable <span
class="citation" data-cites="libkin2004elements">(<a
href="#ref-libkin2004elements" role="doc-biblioref">Libkin
2004</a>)</span>.</p>
<p>Note that Lowenheim’s theorem (Section <a href="#sec:finite-models"
data-reference-type="ref" data-reference="sec:finite-models">2.5</a>)
establishes that any satisfiable formula in first order logic is
satisfiable in an interpretation with a countable domain. Trakhtenbrot’s
theorem is in some sense complementary to this result, since it states
that even if we consider only interpretations with finite domains, the
validity problem in first order logic is still fundamentally hard i.e.
undecidable.</p>
<section id="decidable-classes" class="level3" data-number="2.6.1">
<h3 data-number="2.6.1"><span class="header-section-number">2.6.1</span>
Decidable Classes</h3>
<p>There are, however, interpretations under which validity in first
order logic is decidable. The theory of Presburger arithmetic, which
includes addition but omits multiplication, is decidable. In addition,
checking validity of formulas in <em>monadic predicate calculus</em> are
also decidable <span class="citation"
data-cites="lewis1980complexity">(<a href="#ref-lewis1980complexity"
role="doc-biblioref">Lewis 1980</a>)</span>. This is a fragment of first
order logic in which all relation symbols are <em>monadic</em> i.e. they
take only one argument, and there are no function symbols. That is, all
atomic formulas are of the form <span
class="math inline">\(P(x)\)</span>, where <span
class="math inline">\(P\)</span> is a relation symbol and <span
class="math inline">\(x\)</span> is a variable.</p>
<p>Other decidable cases of first order logic can be defined by the
structure of quantifier prefix. We define a formula of first order logic
as <em>pure</em> if it contains no function symbols (including constants
which are 0-ary function symbols). There are decision procedures for the
validity of pure PCNF formulas whose quantifier prefixes are of one of
the following forms: <span class="math display">\[\begin{aligned}
    &amp;\forall x_1\dots\forall x_n \,\exists x_1\dots\exists x_n \\
    &amp;\forall x_1\dots\forall x_n \, \exists y \, \forall
z_1\dots\forall z_m \\
    &amp;\forall x_1\dots\forall x_n \, \exists y_1 \exists y_2 \,
\forall z_1\dots\forall z_m
\end{aligned}\]</span> which are abbreviated as <span
class="math inline">\(\forall^*\exists^*\)</span>, <span
class="math inline">\(\forall^*\exists\forall^*\)</span>, <span
class="math inline">\(\forall^*\exists\exists\forall^*\)</span> <span
class="citation" data-cites="Dreben1979TheDP">(<a
href="#ref-Dreben1979TheDP" role="doc-biblioref">Dreben and Goldfarb
1979</a>)</span>.</p>
<p>Note that if validity is decidable for a class of formulas, then we
can always check if a formula <span class="math inline">\(\phi\)</span>
in this class is satisfiable by checking if <span
class="math inline">\(\neg \phi\)</span> is valid, and applying the
following simple rule: <span class="math display">\[\begin{aligned}
    &amp;\neg \phi \text{ is valid} \Rightarrow \phi \text{ is not
satisfiable}\\
    &amp;\neg \phi \text{ is not valid} \Rightarrow \phi \text{ is
satisfiable}
\end{aligned}\]</span> Recall that if <span class="math inline">\(\neg
\phi\)</span> is valid this means that there are <em>no</em> satisfying
interpretations for <span class="math inline">\(\phi\)</span>. Thus,
<span class="math inline">\(\phi\)</span> is unsatisfiable. If <span
class="math inline">\(\neg \phi\)</span> is not valid, then this means
there must be some interpretations that do not satisfy <span
class="math inline">\(\neg \phi\)</span>, meaning <span
class="math inline">\(\phi\)</span> must be satisfiable.</p>
<p>Similarly, if satisfiability is decidable for a class of formulas
<span class="math inline">\(F\)</span>, then validity should be
decidable for the <em>negation</em> of formulas in that class. That is,
for any <span class="math inline">\(\phi \in F\)</span>, if checking
<span class="math inline">\(SAT(\phi)\)</span> is decidable, then we can
check validity of <span class="math inline">\(\phi\)</span> by checking
<span class="math inline">\(UNSAT(\neg \phi)\)</span>, but <span
class="math inline">\(\neg \phi\)</span> may no longer fall into the
decidable class <span class="math inline">\(F\)</span>. So, if SAT is
decidable for a formula class <span class="math inline">\(F\)</span>,
then for any <span class="math inline">\(\phi \in F\)</span>, we know
validity is decidable for <span class="math inline">\(\neg
\phi\)</span>, since we can check validity as <span
class="math inline">\(UNSAT(\neg (\neg \phi))=UNSAT(\phi)\)</span>,
which is decidable since SAT for <span
class="math inline">\(\phi\)</span> is decidable.</p>
</section>
<section id="epr" class="level3" data-number="2.6.2">
<h3 data-number="2.6.2"><span class="header-section-number">2.6.2</span>
EPR</h3>
<p>For the so-called <em>Bernays-Schönfinkel class</em>, consisting of
pure formulas (no function symbols) with prefixes of the form <span
class="math inline">\(\exists^*\forall^*\)</span>, satisfiability is
decidable <span class="citation" data-cites="lewis1980complexity">(<a
href="#ref-lewis1980complexity" role="doc-biblioref">Lewis
1980</a>)</span>. This class is alternately referred to as <em>EPR</em>
(<strong>e</strong>ffectively <strong>pr</strong>opositional), since it
can be effectively translated into propositional logic formulas by a
process of grounding or instantiation. That is, satisfiability for EPR
formulas can be reduced to SAT by first replacing all existential
variables by Skolem constants, and then grounding the universally
quantified variables by all combinations of constants. This process
produces a propositional formula that is exponentially larger than the
original <span class="citation" data-cites="demoura2008deciding">(<a
href="#ref-demoura2008deciding" role="doc-biblioref">Moura, Piskac, and
Bjørner 2008</a>)</span>.</p>
<p>More precisely, we can decide satisfiability for EPR as follows <span
class="citation" data-cites="Kroening2016">(<a href="#ref-Kroening2016"
role="doc-biblioref">Kroening and Strichman 2016</a>)</span>, if we
consider an example formula like: <span
class="math display">\[\begin{aligned}
    \exists e_1 \exists e_2 \forall a_1 \forall a_2 : p(e_1,a_1) \vee
q(e_2,a_2)
\end{aligned}\]</span></p>
<ol>
<li><p>First, remove the outer existential quantifiers, which we can do
since it doesn’t affect satisfiability of the remaining formula, giving
<span class="math display">\[\begin{aligned}
        \forall a_1 \forall a_2 : p(e_1,a_1) \vee q(e_2,a_2)
    
\end{aligned}\]</span></p></li>
<li><p>Then, we do a process called <em>grounding</em>, by eliminating
each universal quantifier by forming a conjunction of instantiations of
the suffix with every possible variable that was originally
existentially quantified. Given <span class="math inline">\(n\)</span>
existentially and <span class="math inline">\(m\)</span> universally
quantified variables, this steps results in a formula with <span
class="math inline">\(n^m\)</span> conjuncts. <span
class="math display">\[\begin{aligned}
        &amp;(p(e_1,e_1) \vee q(e_2,e_1)) \wedge \\
        &amp;(p(e_1,e_1) \vee q(e_2,e_2)) \wedge \\
        &amp;(p(e_1,e_2) \vee q(e_2,e_1)) \wedge \\
        &amp;(p(e_1,e_2) \vee q(e_2,e_2))
    
\end{aligned}\]</span></p></li>
<li><p>Now, we are simply left with a boolean combination of
uninterpreted predicates. So, all that’s left is to check whether we can
assign a boolean value to each such predicate under the constraint that
two instances of the same predicate invoked with the same arguments are
assigned the same value. So, we can simply encode this as a plain SAT
problem where each predicate is encoded with a propositional variable
that corresponds to the signature of its parameters e.g. the predicate
<span class="math inline">\(p(e_1,e_2)\)</span> is encoded with a
propositional variable <span class="math inline">\(p_{12}\)</span>. This
gives us the propositional formula: <span
class="math display">\[\begin{aligned}
        &amp;(p_{11} \vee q_{21}) \wedge \\
        &amp;(p_{11} \vee q_{22}) \wedge \\
        &amp;(p_{12} \vee q_{21}) \wedge \\
        &amp;(p_{12} \vee q_{22})  
    
\end{aligned}\]</span></p></li>
<li><p>Then, we just hand this problem to a SAT solver. The formula
obtained is equisatisfiable with the original formula. That is, we are
simply asking the SAT solver whether there exists a set of value
assignments for each predicate that makes the overall statement
true.</p></li>
</ol>
<p>Since the size of the finite satisfying model for formulas in this
class have a computable bound determined by the quantifier prefix, this
means we should also be able to check validity of the negation of
formulas in this class i.e. those with prefix <span
class="math inline">\(\forall^*\exists^*\)</span>, by simply checking
satisfiability for all models up to the required bound. If all cases are
unsatisfiable, then this should be sufficient to establish validity.</p>
</section>
</section>
</section>
<section id="bibliography" class="level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent"
data-entry-spacing="0" role="list">
<div id="ref-2007decidablefragmentsmanysorted" class="csl-entry"
role="listitem">
Abadi, Aharon, Alexander Rabinovich, and Mooly Sagiv. 2007.
<span>“Decidable Fragments of Many-Sorted Logic.”</span> In <em>Logic
for Programming, Artificial Intelligence, and Reasoning</em>, edited by
Nachum Dershowitz and Andrei Voronkov, 17–31. Berlin, Heidelberg:
Springer Berlin Heidelberg.
</div>
<div id="ref-2012benari" class="csl-entry" role="listitem">
Ben-Ari, M. 2012. <span>“Mathematical Logic for Computer
Science.”</span> In, 3rd ed. London: Springer.
</div>
<div id="ref-Dreben1979TheDP" class="csl-entry" role="listitem">
Dreben, Burton, and Warren D. Goldfarb. 1979. <span>“The Decision
Problem: Solvable Classes of Quantificational Formulas.”</span> In.
</div>
<div id="ref-2009completeinstant" class="csl-entry" role="listitem">
Ge, Yeting, and Leonardo de Moura. 2009. <span>“Complete Instantiation
for Quantified Formulas in Satisfiabiliby Modulo Theories.”</span> In
<em>Computer Aided Verification</em>, edited by Ahmed Bouajjani and Oded
Maler, 306–20. Berlin, Heidelberg: Springer Berlin Heidelberg.
</div>
<div id="ref-Kroening2016" class="csl-entry" role="listitem">
Kroening, Daniel, and Ofer Strichman. 2016. <span>“Quantified
Formulas.”</span> In <em>Decision Procedures: An Algorithmic Point of
View</em>, 199–227. Berlin, Heidelberg: Springer Berlin Heidelberg. <a
href="https://doi.org/10.1007/978-3-662-50497-0_9">https://doi.org/10.1007/978-3-662-50497-0_9</a>.
</div>
<div id="ref-lewis1980complexity" class="csl-entry" role="listitem">
Lewis, Harry R. 1980. <span>“<span class="nocase">Complexity results for
classes of quantificational formulas</span>.”</span> <em>Journal of
Computer and System Sciences</em> 21 (3): 317–53.
</div>
<div id="ref-libkin2004elements" class="csl-entry" role="listitem">
Libkin, Leonid. 2004. <em>Elements of Finite Model Theory</em>. Vol. 41.
Springer.
</div>
<div id="ref-2020ivymultimodal" class="csl-entry" role="listitem">
McMillan, Kenneth L., and Oded Padon. 2020. <span>“Ivy: A Multi-Modal
Verification Tool for Distributed Algorithms.”</span> In <em>Computer
Aided Verification</em>, edited by Shuvendu K. Lahiri and Chao Wang,
190–202. Cham: Springer International Publishing.
</div>
<div id="ref-2016merzmanysorted" class="csl-entry" role="listitem">
Merz, Stephan, and Hernán Vanzetto. 2016. <span>“Encoding TLA+ into
Many-Sorted First-Order Logic.”</span> In <em>Abstract State Machines,
Alloy, b, TLA, VDM, and z</em>, edited by Michael Butler, Klaus-Dieter
Schewe, Atif Mashkoor, and Miklos Biro, 54–69. Cham: Springer
International Publishing.
</div>
<div id="ref-demoura2008deciding" class="csl-entry" role="listitem">
Moura, Leonardo de, Ruzica Piskac, and Nikolaj Bjørner. 2008.
<span>“<span class="nocase">Deciding Effectively Propositional Logic
using DPLL and Substitution Sets</span>.”</span> MSR-TR-2008-104.
Springer-Verlag. <a
href="https://www.microsoft.com/en-us/research/publication/deciding-effectively-propositional-logic-using-dpll-and-substitution-sets/">https://www.microsoft.com/en-us/research/publication/deciding-effectively-propositional-logic-using-dpll-and-substitution-sets/</a>.
</div>
<div id="ref-padon2016ivy" class="csl-entry" role="listitem">
Padon, Oded, Kenneth L McMillan, Aurojit Panda, Mooly Sagiv, and Sharon
Shoham. 2016. <span>“Ivy: Safety Verification by Interactive
Generalization.”</span> In <em>Proceedings of the 37th ACM SIGPLAN
Conference on Programming Language Design and Implementation</em>,
614–30.
</div>
<div id="ref-2014manysortedlogic" class="csl-entry" role="listitem">
Vaananen, Jouko. 2014. <span>“Many-Sorted Logic.”</span> <a
href="http://www.math.helsinki.fi/logic/opetus/msl/ILLC_MSL_2014.1.pdf"
class="uri">http://www.math.helsinki.fi/logic/opetus/msl/ILLC_MSL_2014.1.pdf</a>.
<a
href="http://www.math.helsinki.fi/logic/opetus/msl/ILLC_MSL_2014.1.pdf">http://www.math.helsinki.fi/logic/opetus/msl/ILLC_MSL_2014.1.pdf</a>.
</div>
</div>
</section>
</body>
</html>
