<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="William Schultz" />
  <meta name="author" content="William Schultz" />
  <title>Model Checking</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
  <link rel="stylesheet" href="../../style.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Model Checking</h1>
<p class="author">William Schultz</p>
<p class="author">William Schultz</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#temporal-logic-model-checking"><span class="toc-section-number">1</span> Temporal Logic Model Checking</a>
<ul>
<li><a href="#ctl-model-checking">CTL Model Checking</a></li>
<li><a href="#ltl-model-checking">LTL Model Checking</a></li>
<li><a href="#liveness-to-safety-translation">Liveness to Safety Translation</a></li>
</ul></li>
<li><a href="#abstraction-for-model-checking"><span class="toc-section-number">2</span> Abstraction for Model Checking</a>
<ul>
<li><a href="#abstraction-of-kripke-structures">Abstraction of Kripke Structures</a>
<ul>
<li><a href="#simulation">Simulation</a></li>
<li><a href="#bisimulation">Bisimulation</a></li>
<li><a href="#existential-abstraction">Existential Abstraction</a></li>
<li><a href="#trace-equivalence-vs.-bisimulation">Trace Equivalence vs. Bisimulation</a></li>
</ul></li>
<li><a href="#counterexample-guided-abstraction-refinement-cegar">Counterexample-Guided Abstraction Refinement (CEGAR)</a>
<ul>
<li><a href="#identifying-spurious-counterexamples">Identifying Spurious Counterexamples</a></li>
</ul></li>
<li><a href="#sat-based-abstraction">SAT-based Abstraction</a>
<ul>
<li><a href="#interpolation">Interpolation</a></li>
</ul></li>
</ul></li>
<li><a href="#ic3pdr"><span class="toc-section-number">3</span> IC3/PDR</a>
<ul>
<li><a href="#safety-and-counterexamples-to-induction"><span class="toc-section-number">3.1</span> Safety and Counterexamples to Induction</a></li>
</ul></li>
<li><a href="#invariant-inference"><span class="toc-section-number">4</span> Invariant Inference</a>
<ul>
<li><a href="#houdini">Houdini</a></li>
</ul></li>
<li><a href="#bibliography">References</a></li>
</ul>
</nav>
<p>At a high level, <em>model checking</em> is a computer assisted method for the analysis of dynamical systems that can be modeled as discrete state transition systems <span class="citation" data-cites="Clarke2018ch1">(<a href="#ref-Clarke2018ch1" role="doc-biblioref">Edmund M. Clarke, Henzinger, and Veith 2018</a>)</span>. In the basic setting, we can view the model checking problem as taking in a transition system (e.g. a Kripke structre) <span class="math inline">\(K\)</span> and some system specification <span class="math inline">\(\upvarphi\)</span> (typically specified in some temporal logic) and verifying whether <span class="math display">\[\begin{aligned}
    K \vDash \upvarphi\end{aligned}\]</span> and, if <span class="math inline">\(K \nvDash \upvarphi\)</span>, returning a counterexample. In the basic scenario, we can assume <span class="math inline">\(K\)</span> is finite state.</p>
<section id="temporal-logic-model-checking" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Temporal Logic Model Checking</h1>
<p>There are a variety of temporal logics that have been used to reason about properties of programs/systems. A high level overview is shown in the relationship diagram below, where CTL* is one of the most expressive logics (encompassing both CTL and LTL).</p>
<div class="center">
<p><img src="diagrams/temp-logics.png" alt="image" /></p>
</div>
<p>In practice, I don’t think it’s that important to worry much about the finer distinctions between the various logics, since typically I am more concerned with how to express a desired correctness property (e.g. for which LTL may often be sufficient). Nevertheless, it is good to have a general view of the classification hierarchy to understand the landscape (and since various papers may choose to express/formalize things in different choices of logics).</p>
<p>The below diagram also shows the relationship between LTL, CTL, and CTL*. Namely, that LTL and CTL are not directly comparable, and CTL* subsumes them both.</p>
<div class="center">
<p><img src="diagrams/Expressive-Power-of-LTL-CTL-and-CTL.png" alt="image" /></p>
</div>
<p>The following diagram <span class="citation" data-cites="Clarke2018ch1">(<a href="#ref-Clarke2018ch1" role="doc-biblioref">Edmund M. Clarke, Henzinger, and Veith 2018</a>)</span> also provides a good overview of common varieties of temporal logic properties and their counterexample characterizations.</p>
<div class="center">
<p><img src="diagrams/common_ctl_ltl_formulas.png" alt="image" /></p>
</div>
<section id="ctl-model-checking" class="level2 unnumbered">
<h2 class="unnumbered">CTL Model Checking</h2>
<p>For <em>computation tree logic</em> (CTL), there is a model-checking algorithm whose running time depends linearly on the size of the Kripke structure and on the length of the CTL formula <span class="citation" data-cites="1986clarkeemerson">(<a href="#ref-1986clarkeemerson" role="doc-biblioref">E. M. Clarke, Emerson, and Sistla 1986</a>)</span>.</p>
</section>
<section id="ltl-model-checking" class="level2 unnumbered">
<h2 class="unnumbered">LTL Model Checking</h2>
<p>For <em>linear temporal logic</em> (LTL) it is the case that any counterexample to a property <span class="math inline">\(\psi\)</span> is w.l.o.g. restricted to have a “lasso” shape <span class="math inline">\(v\cdot w^{\omega}\)</span> i.e., an initial path (prefix) followed by an infinitely repeated finite path (cycle) <span class="citation" data-cites="1983wolpervardi">(<a href="#ref-1983wolpervardi" role="doc-biblioref">Wolper, Vardi, and Sistla 1983</a>)</span>. Certain LTL properties have even simpler counterexamples e.g. safety properties always have finite paths as counterexamples. Note that the “lasso”-ness of LTL counterexamples is exploited in certain model checking approaches e.g. some liveness to safety reductions <span class="citation" data-cites="BIERE2002160">(<a href="#ref-BIERE2002160" role="doc-biblioref">Biere, Artho, and Schuppan 2002a</a>)</span>.</p>
<div class="center">
<p><img src="diagrams/ltl-lasso.png" alt="image" /></p>
</div>
<p>There is an LTL model checking algorithm whose running time depends linearly on the size of the Kripke structure and exponentially on the length of the LTL formula <span class="citation" data-cites="1985pnuelilich">(<a href="#ref-1985pnuelilich" role="doc-biblioref">Lichtenstein and Pnueli 1985</a>)</span>. This is done by translating an LTL specification <span class="math inline">\(\psi\)</span> into a B<span>ü</span>chi automata <span class="math inline">\(B_{\psi}\)</span> over the alphabet <span class="math inline">\(2^A\)</span> (where <span class="math inline">\(A\)</span> is the set of atomic propositions) such that for all Kripke structures <span class="math inline">\(K\)</span> and infinite paths <span class="math inline">\(\pi\)</span>, the infinite word <span class="math inline">\(L(\pi)\)</span> is accepted by <span class="math inline">\(B_{\psi}\)</span> iff <span class="math inline">\(\pi\)</span> is a counterexample of <span class="math inline">\(\psi\)</span> in <span class="math inline">\(K\)</span>. The size of the automaton <span class="math inline">\(B_{\psi}\)</span>, though, can be exponential in the length of the formula <span class="math inline">\(\psi\)</span>.</p>
<p>More precisely, we translate the negation of our property <span class="math inline">\(\neg \psi\)</span> into a Buchi automaton, and then consider the product of this automaton with our original system <span class="math inline">\(K \times B_{\neg \psi}\)</span>. The problem then reduces to checking whether there are any accepting runs in <span class="math inline">\(K \times B_{\neg \psi}\)</span>. Recall that an accepting run in a (deterministic) Buchi automaton is any run that visits an accepting state infinitely often. A standard algorithm for checking existence of an accepting run consists of</p>
<ol>
<li><p>Consider the automaton as a directed graph and decompose it into its <a href="https://will62794.github.io/my-notes/notes/Strongly_Connected_Components/Strongly_Connected_Components.html">strongly connected components</a> (SCCs).</p></li>
<li><p>Run a search to find which SCCs are reachable from the initial state</p></li>
<li><p>Check whether there is a non-trivial SCC (i.e. consists of <span class="math inline">\(\geq 1\)</span> vertex) that is reachable and contains an accepting state.</p></li>
</ol>
<p>Technically, the LTL model checking problem is PSPACE-complete <span class="citation" data-cites="1985sistlaclarke">(<a href="#ref-1985sistlaclarke" role="doc-biblioref">Sistla and Clarke 1985</a>)</span>, but it’s worth keeping in mind that in practice the limiting complexity factor is usually the size of a system’s state space, rather than the size of the temporal specification. (TODO: why PSPACE?)</p>
</section>
<section id="liveness-to-safety-translation" class="level2 unnumbered">
<h2 class="unnumbered">Liveness to Safety Translation</h2>
<p>Safety checking (e.g. checking invariants) amounts to reachability analysis on the state graph of a transition system/Kripke structure. It turns out we can apply the same verification approach to liveness properties, motivated by the fact that violations to liveness properties in finite systems are <em>lasso</em>-shaped i.e. they consist of a prefix that leads to a loop. The problem then becomes how to detect such a loop. In the translation given in <span class="citation" data-cites="2002bierelivenessassafety">(<a href="#ref-2002bierelivenessassafety" role="doc-biblioref">Biere, Artho, and Schuppan 2002b</a>)</span>, the loop is found by saving a previously visited state and later checking whether the current state already occurred.</p>
</section>
</section>
<section id="abstraction-for-model-checking" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Abstraction for Model Checking</h1>
<p>Abstraction, in the context of model checking, is generally aimed at reducing the size of the state space in an attempt to remove details that are irrelevant to the property being verified <span class="citation" data-cites="Dams2018">(<a href="#ref-Dams2018" role="doc-biblioref">Dams and Grumberg 2018</a>)</span>. That is, broadly, abstraction is a fundamental tool in tackling the “state explosion” problem.</p>
<section id="abstraction-of-kripke-structures" class="level2 unnumbered">
<h2 class="unnumbered">Abstraction of Kripke Structures</h2>
<p>In general, an abstraction framework defines a set of concrete objects and abstract objects and a definition of how to map between them. For model checking, we typically use Kripke structures as our concrete objects. Recall that a <em>Kripe structure</em> <span class="math inline">\(M=(AP,S,I,R,L)\)</span> is defined as</p>
<ul>
<li><p>a set <span class="math inline">\(AP\)</span> of atomic propositions</p></li>
<li><p>a set of states <span class="math inline">\(S\)</span></p></li>
<li><p>a set of initial states <span class="math inline">\(I \subseteq S\)</span></p></li>
<li><p>a transition relation <span class="math inline">\(R \subseteq S \times S\)</span></p></li>
<li><p>a labeling function <span class="math inline">\(L : S \rightarrow 2^{AP}\)</span></p></li>
</ul>
<section id="simulation" class="level3 unnumbered">
<h3 class="unnumbered">Simulation</h3>
<p>To define a notion of abstraction for Kripke structures, we define a few standard relations between two structures <span class="math inline">\(M_1\)</span> and <span class="math inline">\(M_2\)</span>. <em>Simulation</em> is a preorder (a reflexive and transitive partial order) in which the larger structure may have more behaviors, but possibly fewer states and transitions.</p>
<p>Let <span class="math inline">\(M_1=(AP_1,S_1,I_1,R_1,L_1)\)</span> and <span class="math inline">\(M_2=(AP_2,S_2,I_2,R_2,L_2)\)</span> be Kripke structures such that <span class="math inline">\(AP_2 \subseteq AP_1\)</span>. A relation <span class="math inline">\(H\)</span> is a <em>simulation relation from <span class="math inline">\(M_1\)</span> to <span class="math inline">\(M_2\)</span></em> if for every <span class="math inline">\(s_1 \in S_1\)</span> and <span class="math inline">\(s_2 \in S_2\)</span> such that <span class="math inline">\(H(s_1,s_2)\)</span>, both of the following conditions hold:</p>
<ul>
<li><p><span class="math inline">\(\forall p \in AP_2 : p \in L_1(s_1) \iff p \in L_2(s_2)\)</span></p></li>
<li><p><span class="math inline">\(\forall t_1 \in S_1 :  R_1(s_1,t_1) \Rightarrow \exists t_2 : (R_2(s_2,t_2) \wedge H(t_1,t_2))\)</span></p></li>
</ul>
<p>Note that it is helpful to visually illustrate these conditions e.g. if there is a (blue) transition <span class="math inline">\(s_1 \rightarrow s_1&#39;\)</span> in system <span class="math inline">\(M_1\)</span>, and states <span class="math inline">\(s_1,s_2\)</span> are related via the simulation relation <span class="math inline">\(H\)</span>, then there must exist a (red) transition <span class="math inline">\(s_2 \rightarrow s_2&#39;\)</span> such that <span class="math inline">\((s_1&#39;,s_2&#39;) \in H\)</span>.</p>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\textcolor{blue}{s_1}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\overset{H}{\longrightarrow}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\textcolor{red}{s_2}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\textcolor{blue}{\downarrow}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(\textcolor{red}{\downarrow}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\textcolor{blue}{s_1&#39;}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\overset{H}{\longrightarrow}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\textcolor{red}{s_2&#39;}\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>The second condition states that for every transition of the “smaller” (i.e. more concrete) system <span class="math inline">\(M_1\)</span>, there must exist a corresponding transition in the larger system <span class="math inline">\(M_2\)</span>. We say that <span class="math inline">\(M_1\)</span> <em>is simulated by</em> <span class="math inline">\(M_2\)</span> (or <span class="math inline">\(M_2\)</span> <em>simulates</em> <span class="math inline">\(M_1\)</span>), denoted <span class="math inline">\(M_1 \leq M_2\)</span>, if there exists a simulation relation <span class="math inline">\(H\)</span> from <span class="math inline">\(M_1\)</span> to <span class="math inline">\(M_2\)</span> such that <span class="math display">\[\begin{aligned}
    \forall s_1 \in I_1 : (\exists s_2 \in I_2 : H(s_1,s_2))\end{aligned}\]</span> For example, consider the concrete Kripke structure <span class="math inline">\(M\)</span>, modeling a mutual exclusion program where its atomic propositions <span class="math inline">\(AP=\{N_1,T_1,C_1,N_2,T_2,C_2,F_0\}\)</span>:</p>
<div class="center">
<p><img src="diagrams/concrete-mutex.png" alt="image" /></p>
</div>
<p>and then an abstraction of this structure, <span class="math inline">\(M_1\)</span>, with atomic propositions <span class="math inline">\(AP_1=\{C_1,C_2,F_0\}\)</span>:</p>
<div class="center">
<p><img src="diagrams/abstract-mutex.png" alt="image" /></p>
</div>
<p>This abstraction basically only tracks whether a particular process is in the critical section or not, but ignores all other information. Note that <span class="math inline">\(AP_1 \subseteq AP\)</span>. A simulation relation <span class="math inline">\(H \subseteq S \times S_1\)</span> from <span class="math inline">\(M\)</span> to <span class="math inline">\(M_1\)</span> can then be defined as <span class="math display">\[\begin{aligned}
    H = \left\lbrace (s_1, a_1), (s_2, a_1), (s_3, a_1), (s_4, a_2), (s_5, a_1), (s_6, a_3), (s_7, a_2), (s_8, a_3) \right\rbrace\end{aligned}\]</span></p>
</section>
<section id="bisimulation" class="level3 unnumbered">
<h3 class="unnumbered">Bisimulation</h3>
<p>One state is related to another by the bisimulation relation If they agree on their common atomic propositions and, in addition, for every successor of one state there is a corresponding successor of the other state, and <em>vice versa</em>.</p>
</section>
<section id="existential-abstraction" class="level3 unnumbered">
<h3 class="unnumbered">Existential Abstraction</h3>
<p>One way to define an abstract model (Kripke structure) from a concrete one is via a concretization function <span class="math inline">\(\gamma\)</span>. We can define abstract Kripke structures by means of <em>existential abstraction</em> <span class="citation" data-cites="94mcabs">(<a href="#ref-94mcabs" role="doc-biblioref">Edmund M. Clarke, Grumberg, and Long 1994</a>)</span>. Given a set <span class="math inline">\(\widehat{S}\)</span> of abstract states, the <em>concretization function</em> <span class="math inline">\(\gamma : \widehat{S} \rightarrow 2^S\)</span> indicates, for each abstract state <span class="math inline">\(\widehat{s}\)</span>, what set of concrete states are represented by <span class="math inline">\(\widehat{s}\)</span>. Similarly, there is a transition from abstract state <span class="math inline">\(\widehat{s}\)</span> to another abstract state <span class="math inline">\(\widehat{s}&#39;\)</span> if there is a transition from a state represented by <span class="math inline">\(\widehat{s}\)</span> to a state represented by <span class="math inline">\(\widehat{s}&#39;\)</span>. Essentially, we just take every transition between concrete states and add it into our abstract transition system, based on the abstract states that represent those concrete state transitions.</p>
</section>
<section id="trace-equivalence-vs.-bisimulation" class="level3 unnumbered">
<h3 class="unnumbered">Trace Equivalence vs. Bisimulation</h3>
<p>Note that trace inclusion and trace equivalence notions of transition system similiarity or equivalence are often sufficient when concerned with linear time properties (i.e. LTL formulae) <span class="citation" data-cites="2008principlemc">(<a href="#ref-2008principlemc" role="doc-biblioref">Baier and Katoen 2008</a>)</span>. Bisimulation and simulation can be considered primarily as relations that respect the <em>branching time</em> behavior. Bisimulation, for example, is a stronger notion than trace equivalence. That is, if two systems <span class="math inline">\(TS_1\)</span> and <span class="math inline">\(TS_2\)</span> are bisimilar, then they admit the same set of traces. And so, these systems also fulfill the same linear time properties.</p>
</section>
</section>
<section id="counterexample-guided-abstraction-refinement-cegar" class="level2 unnumbered">
<h2 class="unnumbered">Counterexample-Guided Abstraction Refinement (CEGAR)</h2>
<p>Regardless of how we choose our abstraction, our abstract model <span class="math inline">\(\widehat{M}\)</span> generally contains less information than the concrete model <span class="math inline">\(M\)</span>, and so model checking <span class="math inline">\(\widehat{M}\)</span> may produce incorrect results. If a universal property is true in <span class="math inline">\(\widehat{M}\)</span> then it is also true in <span class="math inline">\(M\)</span>, but if the abstract model produces an error, the concrete model may still be correct.</p>
<p>For example consider the following “traffic light” model and a simple abstraction of it</p>
<div class="center">
<p><img src="diagrams/cegar1.png" alt="image" /></p>
</div>
<p>If we wanted to check the universal CTL property <span class="math inline">\(\textbf{AGAF}(IsRed)\)</span> (i.e. along all paths, <span class="math inline">\(IsRed\)</span> holds infinitely often), this clearly holds in the concrete traffic light model, but fails in the abstract model. When an abstract counterexample does not correspond to any concrete counterexample, we call it <em>spurious</em>.</p>
<p>Consider another example of a spurious counterexample, shown as follows:</p>
<div class="center">
<p><img src="diagrams/cegar2.png" alt="image" /></p>
</div>
<p>in this case, reachability of state 11 is not preserved by the abstraction. That is, it is not reachable in the lower level system, but it is reachable in the abstract system (consisting of abstract states <span class="math inline">\(\{a,b,c,d\}\)</span>).</p>
<p>The framework of <em>counterexample-guided abstraction refinement (CEGAR)</em> deals with this issue. The main steps of CEGAR are as follows:</p>
<ol>
<li><p>Given a concrete model <span class="math inline">\(M\)</span> and some universal temporal formula to check, <span class="math inline">\(\psi\)</span>, generate an initial abstract model <span class="math inline">\(\widehat{M}\)</span>.</p></li>
<li><p>Model check <span class="math inline">\(\widehat{M}\)</span> with respect to <span class="math inline">\(\psi\)</span>. If <span class="math inline">\(\widehat{M}\)</span> satisfies <span class="math inline">\(\psi\)</span>, then conclude that the concrete model satisfies <span class="math inline">\(\psi\)</span> and terminate. If a counterexample <span class="math inline">\(\widehat{T}\)</span> is found, check whether it is also a counterexample in the concrete model.</p>
<ul>
<li><p>If it is, conclude that the concrete model does not satisfy the formula and stop.</p></li>
<li><p>Otherwise, the counterexample is spurious, and proceed to step 3.</p></li>
</ul></li>
<li><p>Refine the abstract model, <span class="math inline">\(\widehat{M}\)</span>, so that <span class="math inline">\(\widehat{T}\)</span> will not be included in the new, refined abstract model. Go back to step 2.</p></li>
</ol>
<p>Note that refinement is typically done by <em>partitioning</em> an abstract state. That is, the set of concrete states represented by the abstract state is partitioned</p>
<section id="identifying-spurious-counterexamples" class="level3 unnumbered">
<h3 class="unnumbered">Identifying Spurious Counterexamples</h3>
<p>If we discover an abstract counterexample <span class="math inline">\(\widehat{T}\)</span>, we need some way to check if this is a real counterexample in the concrete model. Assume that <span class="math inline">\(\widehat{T}\)</span> is a path <span class="math inline">\(\widehat{s_1},\dots, \widehat{s_n}\)</span> starting at the initial abstract state <span class="math inline">\(\widehat{s_1}\)</span>. We can extend the concretization function <span class="math inline">\(\gamma\)</span> to sequences of abstract states as follows: <span class="math inline">\(\gamma(\widehat{T})\)</span> is the set of concrete paths defined as: <span class="math display">\[\begin{aligned}
    \gamma(\widehat{T}) = \left\lbrace \langle s_1,\dots,s_n \rangle \mid 
    \bigwedge_{i=1}^n s_i \in \gamma(\widehat{s_i}) \wedge I(s_1) \wedge 
    \bigwedge_{i=1}^n R(s_i,s_{i+1})
    \right\rbrace\end{aligned}\]</span> Then, we need an algorithm to compute a sequence of sets of states that correspond to <span class="math inline">\(\gamma({\widehat{T}})\)</span>. We let <span class="math inline">\(S_1 = \gamma(\widehat{s_1}) \cap I\)</span>, and then define <span class="math display">\[\begin{aligned}
    S_i := Image(S_{i-1}, R) \cap \gamma(\widehat{s_i})\end{aligned}\]</span> where <span class="math inline">\(Image(S_{i-1}, R)\)</span> is the set of successors, in <span class="math inline">\(M\)</span>, of the states in <span class="math inline">\(S_{i-1}\)</span>. Basically, we just want to symbolically execute concrete model, starting from the concretized version of the initial abstract counterexample state, and, at each step, check whether there is some concrete state in this image set that corresponds to the set of states from the abstract counterexample. We can formalize this into the following lemma. Specifically, the following are equivalent:</p>
<ol>
<li><p>The path <span class="math inline">\(\widehat{T}\)</span> corresponds to a concrete counterexample.</p></li>
<li><p>The set <span class="math inline">\(\gamma(\widehat{T})\)</span> of concrete paths is non-empty.</p></li>
<li><p>For all <span class="math inline">\(1 \leq i \leq n, S_i \neq \emptyset\)</span>.</p></li>
</ol>
<p>Note that checking whether a counterexample is spurious involves computations on the concrete model.</p>
</section>
</section>
<section id="sat-based-abstraction" class="level2 unnumbered">
<h2 class="unnumbered">SAT-based Abstraction</h2>
<p>An alternative to the CEGAR based approach (introduced shortly after the initial CEGAR publication) is to rely more directly on a SAT solver for performing abstraction. A main idea is to do bounded model checking and then use proofs of unsatisfiability in this case to provide an <em>explanation</em> of correctness, and to help us generate an abstraction for proving a property in the unbounded case. Using such a proof to generate an abstraction is called <em>proof-based abstraction</em> <span class="citation" data-cites="2003abswithoutcex">(<a href="#ref-2003abswithoutcex" role="doc-biblioref">Kenneth L. McMillan and Amla 2003</a>)</span>.</p>
<p>In the initial work of <span class="citation" data-cites="2003abswithoutcex">(<a href="#ref-2003abswithoutcex" role="doc-biblioref">Kenneth L. McMillan and Amla 2003</a>)</span> (appeared in <em>TACAS 2003</em>, April), verification of a system <span class="math inline">\(M\)</span> is done by performing bounded model checking of <span class="math inline">\(M\)</span> for a fixed bound <span class="math inline">\(k\)</span>. If an error is found for this bound, then we’re done, since a counterexample has been found. Otherwise, the SAT solver can return a (resolution) proof of unsatisfiability. This proof is used to generate an abstraction, <span class="math inline">\(M&#39;\)</span>, of <span class="math inline">\(M\)</span> by seeing what clauses of the encoding of <span class="math inline">\(M\)</span> are actually used in the proof (see <span class="citation" data-cites="2003abswithoutcex">(<a href="#ref-2003abswithoutcex" role="doc-biblioref">Kenneth L. McMillan and Amla 2003</a>)</span> for details). Then, <em>unbounded</em> model checking is performed on the abstract model <span class="math inline">\(M&#39;\)</span>, which should in theory now be much cheaper since <span class="math inline">\(M&#39;\)</span> has been abstracted from <span class="math inline">\(M\)</span>. If model checking determines that there are no error traces in <span class="math inline">\(M&#39;\)</span>, then we are done. Otherwise, if model checking determines that <span class="math inline">\(M&#39;\)</span> does have an error run, then we know its length <span class="math inline">\(k&#39;\)</span> is greater than <span class="math inline">\(k\)</span>. Thus, we then restart the procedure with <span class="math inline">\(k&#39;\)</span> (or, generally, any value larger than <span class="math inline">\(k&#39;\)</span>)</p>
<section id="interpolation" class="level3 unnumbered">
<h3 class="unnumbered">Interpolation</h3>
<p>Slghtly subsequent work by McMillan <span class="citation" data-cites="2003satinterp">(<a href="#ref-2003satinterp" role="doc-biblioref">K. L. McMillan 2003</a>)</span> (appeared in <em>CAV 2003</em>, July) presented an extension of this approach that makes use of <em>interpolation</em> for doing abstraction with a SAT solver. Essentially this uses a similar bounded model checking approach and then extracts an <em>interpolant</em> from a bounded unsatisfiability proof to compute an abstraction.</p>
<p>The standard bounded model checking unrolling is a constraint of the following basic form:</p>
<div class="center">
<p><img src="diagrams/bmc.png" alt="image" /></p>
</div>
<p>The idea of the interpolation based approach is to partition the path constraint into two sets <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>:</p>
<div class="center">
<p><img src="diagrams/bmc-interpolant.png" alt="image" /></p>
</div>
<p>Then, if we produce a proof of unsatisfiability of the whole unrolling constraint, we derive an interpolant <span class="math inline">\(P\)</span> of the pair <span class="math inline">\((A,B)\)</span>, where the common variables of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are exactly those variables representing state <span class="math inline">\(s_1\)</span>, in the sample diagram above. Note that an interpolant <span class="math inline">\(P\)</span> for two formulas <span class="math inline">\(A,B\)</span> is one such that</p>
<ul>
<li><p><span class="math inline">\(A \Rightarrow P\)</span></p></li>
<li><p><span class="math inline">\(P\)</span> refers only to the common variables of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span></p></li>
<li><p><span class="math inline">\(P \wedge B\)</span> is unsatisfiable</p></li>
</ul>
<p>By this, we can know that <span class="math inline">\(P\)</span> is implied by the initial condition and by the first transition constraint, so it represents some approximation of all 1-step reachable states (i.e. it is an over-approximation of the forward image of <span class="math inline">\(I\)</span>). Moreover, <span class="math inline">\(P\)</span> and <span class="math inline">\(B\)</span> are unsatisfiable, meaning that no state satisfying <span class="math inline">\(P\)</span> can reach a final state in <span class="math inline">\(k-1\)</span> steps. This over-approximate image operation can then be iterated to compute an over-approximation of the reachable states.</p>
<ul>
<li><p>What is the difference between abstracting the entire system (e.g. the transition relation) and model checking that (like in CEGAR) vs. coming up with an abstraction of the reachable states and checking for inductiveness? Are these two approaches different but related in some way? Are there advantages to one over the other?</p></li>
</ul>
</section>
</section>
</section>
<section id="ic3pdr" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> IC3/PDR</h1>
<p>IC3/PDR <span class="citation" data-cites="bradley2011sat">(<a href="#ref-bradley2011sat" role="doc-biblioref">Aaron R. Bradley 2011</a>)</span> uses a SAT solver to make simple induction queries, from which it generates counterexamples to induction (CTIs) that it then generalizes into strengthening lemmas. Furthermore, it makes uses of previously accumulated lemmas to make the approach “incremental” i.e. it can check for inductiveness of a candidate lemma in the context of previously discovered lemmas. Some of the foundational ideas for this approach go back to some earlier work of Manna-Bradley <span class="citation" data-cites="2007bradleymannasafety">(<a href="#ref-2007bradleymannasafety" role="doc-biblioref">Aaron R. Bradley and Manna 2007</a>)</span>.</p>
<section id="safety-and-counterexamples-to-induction" class="level2" data-number="3.1">
<h2 data-number="3.1"><span class="header-section-number">3.1</span> Safety and Counterexamples to Induction</h2>
<p>Note some basic facts about inductive invariants and counterexamples to induction. If a property <span class="math inline">\(S\)</span> is a true invariant of your system, but is not inductive, then there will exist some CTIs i.e. states that start in <span class="math inline">\(S\)</span> but leave <span class="math inline">\(S\)</span> via some state transition.</p>
<div class="center">
<p><img src="diagrams/inductive_inv1/inductive_inv1.001.png" alt="image" /></p>
</div>
<p>In the case where <span class="math inline">\(S\)</span> is not a true invariant of your system (meaning your system violates <span class="math inline">\(S\)</span>), but the initial states satisfy <span class="math inline">\(S\)</span>, then there must be some CTI of <span class="math inline">\(S\)</span> (call it <span class="math inline">\(CTI^*\)</span>) that starts in <span class="math inline">\(S \wedge Reach\)</span> and transitions to a state in <span class="math inline">\(\neg S \wedge Reach\)</span> (i.e., it reaches a bad state). There may be other CTIs of <span class="math inline">\(S\)</span> that still start in an unreachable state within <span class="math inline">\(S\)</span> and leave <span class="math inline">\(S\)</span> as in the prior “safe” case. But, in the unsafe case, we can imagine the <span class="math inline">\(CTI^*\)</span> state as being one to find if we actually want to discover the bug in this system. And clearly, we know that if the bad state that is actually reachable from <span class="math inline">\(Init\)</span>, then there must be a backwards path from that state back to <span class="math inline">\(Init\)</span>.</p>
<p>So, if we try to refine <span class="math inline">\(S\)</span> by eliminating each <span class="math inline">\(CTI^*\)</span> in this path, then we should eventually end up with a “CTI” that is an initial state, indicating that we’ve found the bug. That is, we’ve refined <span class="math inline">\(S\)</span> to cut out all non-initial states of the buggy path. We can alternatively think of this through the lens of simple bug-finding via backwards reachability i.e., start from states in <span class="math inline">\(\neg S\)</span> and try to find paths from there that lead back to the initial states.</p>
<div class="center">
<p><img src="diagrams/inductive_inv1/inductive_inv1.002.png" alt="image" /></p>
</div>
</section>
</section>
<section id="invariant-inference" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Invariant Inference</h1>
<p>Most of safety verification centers around inference of suitable inductive invariants <span class="citation" data-cites="mannasafetybook">(<a href="#ref-mannasafetybook" role="doc-biblioref">Manna and Pnueli 1995</a>)</span>. There are many techniques for doing this e.g. some developing in the context of sequential programs for loop invariant synthesis, and other model checking techniques like IC3/PDR <span class="citation" data-cites="bradley2011sat">(<a href="#ref-bradley2011sat" role="doc-biblioref">Aaron R. Bradley 2011</a>)</span> that try to directly synthesize an inductive invariant.</p>
<section id="houdini" class="level2 unnumbered">
<h2 class="unnumbered">Houdini</h2>
<p>Houdini <span class="citation" data-cites="2001leinoflanagan">(<a href="#ref-2001leinoflanagan" role="doc-biblioref">Flanagan and Leino 2001</a>)</span> is an algorithm developed in the context of Java program verification that, given a set of predicates <span class="math inline">\(P\)</span>, finds the largest subset of <span class="math inline">\(P\)</span> that is inductive. The basic algorithm, given a set of predicates <span class="math inline">\(P\)</span> and program transition relation <span class="math inline">\(T\)</span>, initializes <span class="math inline">\(P_H := P\)</span>, and then checks the induction condition <span class="math display">\[\begin{aligned}
    \neg (P_H \wedge T \wedge P_H&#39;)\end{aligned}\]</span> If this is satisfiable, then some CTIs exist for <span class="math inline">\(P_H\)</span>, and the verifier checks which predicates in <span class="math inline">\(P_H\)</span> were verified in the post-state, and removes these predicates from <span class="math inline">\(P_H\)</span>. It repeats this loop until the predicate set <span class="math inline">\(P_H\)</span> is made inductive, giving the largest/maximal (and strongest) inductive subset of <span class="math inline">\(P\)</span>, if one exists.</p>
<p>We can view this as a kind of monotonic weakening procedure i.e. every time we may throw out some conjuncts, weakening the overall predicate until we find something that is inductive, giving the strongest inductive invariant over this predicate set.</p>
<p>Note that this basic algorithm to some extent depends on the size of the predicate set. When having a grammar with a large number of predicates e.g. as generated by a template, this can become an infeasible approach.</p>
</section>
</section>
<section id="bibliography" class="level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-2008principlemc" class="csl-entry" role="doc-biblioentry">
Baier, Christel, and Joost-Pieter Katoen. 2008. <em>Principles of Model Checking</em>. Vol. 26202649.
</div>
<div id="ref-BIERE2002160" class="csl-entry" role="doc-biblioentry">
Biere, Armin, Cyrille Artho, and Viktor Schuppan. 2002a. <span>“Liveness Checking as Safety Checking.”</span> <em>Electronic Notes in Theoretical Computer Science</em> 66 (2): 160–77. https://doi.org/<a href="https://doi.org/10.1016/S1571-0661(04)80410-9">https://doi.org/10.1016/S1571-0661(04)80410-9</a>.
</div>
<div id="ref-2002bierelivenessassafety" class="csl-entry" role="doc-biblioentry">
———. 2002b. <span>“Liveness Checking as Safety Checking.”</span> <em>Electronic Notes in Theoretical Computer Science</em> 66 (2): 160–77. https://doi.org/<a href="https://doi.org/10.1016/S1571-0661(04)80410-9">https://doi.org/10.1016/S1571-0661(04)80410-9</a>.
</div>
<div id="ref-bradley2011sat" class="csl-entry" role="doc-biblioentry">
Bradley, Aaron R. 2011. <span>“SAT-Based Model Checking Without Unrolling.”</span> In <em>International Workshop on Verification, Model Checking, and Abstract Interpretation</em>, 70–87. Springer.
</div>
<div id="ref-2007bradleymannasafety" class="csl-entry" role="doc-biblioentry">
Bradley, Aaron R., and Zohar Manna. 2007. <span>“Checking Safety by Inductive Generalization of Counterexamples to Induction.”</span> In <em>Proceedings of the Formal Methods in Computer Aided Design</em>, 173–80. FMCAD ’07. USA: IEEE Computer Society.
</div>
<div id="ref-1986clarkeemerson" class="csl-entry" role="doc-biblioentry">
Clarke, E. M., E. A. Emerson, and A. P. Sistla. 1986. <span>“Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications.”</span> <em>ACM Trans. Program. Lang. Syst.</em> 8 (2): 244–63. <a href="https://doi.org/10.1145/5397.5399">https://doi.org/10.1145/5397.5399</a>.
</div>
<div id="ref-94mcabs" class="csl-entry" role="doc-biblioentry">
Clarke, Edmund M., Orna Grumberg, and David E. Long. 1994. <span>“Model Checking and Abstraction.”</span> <em>ACM Trans. Program. Lang. Syst.</em> 16 (5): 1512–42. <a href="https://doi.org/10.1145/186025.186051">https://doi.org/10.1145/186025.186051</a>.
</div>
<div id="ref-Clarke2018ch1" class="csl-entry" role="doc-biblioentry">
Clarke, Edmund M., Thomas A. Henzinger, and Helmut Veith. 2018. <span>“Introduction to Model Checking.”</span> In <em>Handbook of Model Checking</em>, edited by Edmund M. Clarke, Thomas A. Henzinger, Helmut Veith, and Roderick Bloem, 1–26. Cham: Springer International Publishing. <a href="https://doi.org/10.1007/978-3-319-10575-8_1">https://doi.org/10.1007/978-3-319-10575-8_1</a>.
</div>
<div id="ref-Dams2018" class="csl-entry" role="doc-biblioentry">
Dams, Dennis, and Orna Grumberg. 2018. <span>“Abstraction and Abstraction Refinement.”</span> In <em>Handbook of Model Checking</em>, edited by Edmund M. Clarke, Thomas A. Henzinger, Helmut Veith, and Roderick Bloem, 385–419. Cham: Springer International Publishing. <a href="https://doi.org/10.1007/978-3-319-10575-8_13">https://doi.org/10.1007/978-3-319-10575-8_13</a>.
</div>
<div id="ref-2001leinoflanagan" class="csl-entry" role="doc-biblioentry">
Flanagan, Cormac, and K. Rustan M. Leino. 2001. <span>“<span class="nocase">Houdini, an Annotation Assistant for ESC/Java</span>.”</span> In <em>Proceedings of the International Symposium of Formal Methods Europe on Formal Methods for Increasing Software Productivity</em>, 500–517. FME ’01. Berlin, Heidelberg: Springer-Verlag.
</div>
<div id="ref-1985pnuelilich" class="csl-entry" role="doc-biblioentry">
Lichtenstein, Orna, and Amir Pnueli. 1985. <span>“Checking That Finite State Concurrent Programs Satisfy Their Linear Specification.”</span> In <em>Proceedings of the 12th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages</em>, 97–107. POPL ’85. New York, NY, USA: Association for Computing Machinery. <a href="https://doi.org/10.1145/318593.318622">https://doi.org/10.1145/318593.318622</a>.
</div>
<div id="ref-mannasafetybook" class="csl-entry" role="doc-biblioentry">
Manna, Zohar, and Amir Pnueli. 1995. <em>Temporal Verification of Reactive Systems: Safety</em>. Berlin, Heidelberg: Springer-Verlag.
</div>
<div id="ref-2003satinterp" class="csl-entry" role="doc-biblioentry">
McMillan, K. L. 2003. <span>“Interpolation and SAT-Based Model Checking.”</span> In <em>Computer Aided Verification</em>, edited by Warren A. Hunt and Fabio Somenzi, 1–13. Berlin, Heidelberg: Springer Berlin Heidelberg.
</div>
<div id="ref-2003abswithoutcex" class="csl-entry" role="doc-biblioentry">
McMillan, Kenneth L., and Nina Amla. 2003. <span>“Automatic Abstraction Without Counterexamples.”</span> In <em>Proceedings of the 9th International Conference on Tools and Algorithms for the Construction and Analysis of Systems</em>, 2–17. TACAS’03. Berlin, Heidelberg: Springer-Verlag.
</div>
<div id="ref-1985sistlaclarke" class="csl-entry" role="doc-biblioentry">
Sistla, A. P., and E. M. Clarke. 1985. <span>“The Complexity of Propositional Linear Temporal Logics.”</span> <em>J. ACM</em> 32 (3): 733–49. <a href="https://doi.org/10.1145/3828.3837">https://doi.org/10.1145/3828.3837</a>.
</div>
<div id="ref-1983wolpervardi" class="csl-entry" role="doc-biblioentry">
Wolper, Pierre, Moshe Y. Vardi, and A. Prasad Sistla. 1983. <span>“Reasoning about Infinite Computation Paths.”</span> In <em>Proceedings of the 24th Annual Symposium on Foundations of Computer Science</em>, 185–94. SFCS ’83. USA: IEEE Computer Society. <a href="https://doi.org/10.1109/SFCS.1983.51">https://doi.org/10.1109/SFCS.1983.51</a>.
</div>
</div>
</section>
</body>
</html>
