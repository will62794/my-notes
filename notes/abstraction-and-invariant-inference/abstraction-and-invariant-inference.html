<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="William Schultz" />
  <title>Abstraction and Invariant Inference</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="../../style.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Abstraction and Invariant Inference</h1>
<p class="author">William Schultz</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#abstraction-domains">Abstraction Domains</a></li>
<li><a href="#learning-inductive-invariants">Learning Inductive Invariants</a></li>
</ul>
</nav>
<p>For the safety verification of transition systems, we typically must perform some kind of <em>abstraction</em>. For finite transition systems, verification is theoretically decidable, but practically it suffers from the state space explosion problem, and so exhaustive verification may be hard (e.g. exponential) in general. So, for verifying any systems of non-trivial size, abstraction is typically necessary. Finding an inductive invariant to prove safety is, essentially, about finding a suitable abstraction that overapproximates the set of reachable system states. Furthermore, we presumably want this abstraction to be “concise" i.e. it doesn’t scale in proportion to the size of the transition system (e.g. the number of states).</p>
<section id="abstraction-domains" class="level2 unnumbered">
<h2 class="unnumbered">Abstraction Domains</h2>
<p>In general, in order to discover a “concise" inductive invariant we must work over some <em>abstraction domain</em>. Given a state space <span class="math inline">\(S\)</span>, we can define an <em>abstraction domain</em> <span class="math inline">\(D \subseteq 2^S\)</span> as simply a set of subsets of <span class="math inline">\(S\)</span>. For example, given the state space defined by a single real valued variable <span class="math inline">\(x \in \mathbb{R}\)</span>, a possible abstraction domain is <span class="math display">\[\begin{aligned}
    D_1 = \{x &gt; 2, x &lt; - 2\}\end{aligned}\]</span> where each element of <span class="math inline">\(D_1\)</span> is a subset of <span class="math inline">\(\mathbb{R}\)</span>, defined as a symbolic predicate over <span class="math inline">\(x\)</span>.</p>
<p>One way to define an abstraction domain for a state space <span class="math inline">\(S\)</span> is to explicitly define the set <span class="math inline">\(D \subseteq 2^S\)</span>. Alternatively we can provide a set of atomic predicates and rules for for how these predicates can be combined to form additional predicates. Our abstraction domain is then defined as the space of all possible composite predicates that can be formed as combinations of atomic predicates, perhaps up to some bounded size. We can call this the <em>grammar-based</em> approach.</p>
<p>For example, for a state space <span class="math inline">\(S\)</span> we can define a <em>grammar</em> <span class="math inline">\(G\)</span> as a pair <span class="math inline">\((P,O)\)</span> where <span class="math inline">\(P \subseteq 2^S\)</span> is a set of predicates on <span class="math inline">\(S\)</span>, and <span class="math inline">\(O\)</span> is a set of operators for combining elements of <span class="math inline">\(P\)</span> to form new predicates on <span class="math inline">\(S\)</span>. These operators may be unary, binary, etc. For example, we may have a grammar <span class="math inline">\(G_1 = (\{x&gt;2, x &lt; 3\}, \{\neg, \vee\})\)</span>. We can refer to the abstraction domain defined by a grammar <span class="math inline">\(G\)</span> as <span class="math inline">\(\mathcal{D}(G)\)</span>.</p>
<p>For finite state systems with a state space <span class="math inline">\(S\)</span>, we can also always work over an abstraction domain that consists of all predicates that contain a single state <span class="math inline">\(s \in S\)</span>. That is, the abstraction domain <span class="math inline">\(D_{\bot} = \{\{s\} \mid s \in S\}\)</span>, which we can view as “minimally abstract” (i.e. predicates don’t generalize across multiple states).</p>
</section>
<section id="learning-inductive-invariants" class="level2 unnumbered">
<h2 class="unnumbered">Learning Inductive Invariants</h2>
<p>Now, given a particular abstraction domain <span class="math inline">\(D\)</span>, is it possible to learn an inductive invariant? If we have a transition system with a set of reachable states <span class="math inline">\(Reach\)</span> and an inductive invariant <span class="math inline">\(Ind\)</span> that is a strict superset of <span class="math inline">\(Reach\)</span>, one approach to searching for an inductive invariant is to define as our abstraction domain a set of invariants of this transition system. These invariants themselves could be defined in terms of some grammar, via atomic predicates and boolean connectives, but overall we just care about the set of invariants we can work with. If we search for an inductive invariant by picking new invariants one at a time, are we guaranteed to converge to an inductive invariant if one exists?</p>
<p>Consider the simple case below, where there are two inductive invariants (<span class="math inline">\(Ind\)</span> and <span class="math inline">\(Reach\)</span>) that exist, and <span class="math inline">\(Ind\)</span> is expressible as a conjunctino of invariants in our abstraction domain.</p>
<div class="center">
<p><img src="invs1.png" style="width:70mm" alt="image" /></p>
</div>
<p>There are 3 invariants in our domain, <span class="math inline">\(L_1,L_2,L_3\)</span>. If we select invariants in some order, are we guaranteed to converge to an inductive invariant? If we select <span class="math inline">\(L_1\)</span> and then <span class="math inline">\(L_2\)</span>, then we will converge to <span class="math inline">\(Ind\)</span>. But, if we select <span class="math inline">\(L_1\)</span> and then <span class="math inline">\(L_3\)</span>, we will end up with a resulting predicate <span class="math inline">\(L_1 \wedge L_3\)</span> that is stronger than <span class="math inline">\(Ind\)</span>, and we end up stuck, since there are no inductive ivnariants stronger than <span class="math inline">\(Ind\)</span> that are expressible in our abstraction domain. So, if we follow a strategy of strict refinement (always combining via conjunction), then we are inevitably stuck in this case. We could potentially undo a past choice, however, and try a different invariant selection strategy, in the style of standard backtracking search. But, a question is how to detect when we end up in this "dead end" refinement scenario.</p>
<p>If an inductive invariant exists that is representable in a given abstraction domain, will counterexample guided invariant search always find it?</p>
<p>We can say that our abstraction domain consists of the set of all invariants expressible by some given grammar. Then, we want to ask whether by selecting invariants in some manner, is it always possible we will learn</p>
<ul>
<li><p>If you start off with a fixed abstraction domain, is there a way to dynamically adjust the domain if you realize that it cannot express the concepts (e.g. invariants) you want to express?</p></li>
</ul>
</section>
</body>
</html>
