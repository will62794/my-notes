<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="William Schultz" />
  <title>Abstraction and Invariant Inference</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="../../style.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Abstraction and Invariant Inference</h1>
<p class="author">William Schultz</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#abstraction-domains">Abstraction Domains</a></li>
<li><a href="#learning-inductive-invariants">Learning Inductive Invariants</a></li>
<li><a href="#other-techniques">Other Techniques</a></li>
<li><a href="#open-questions">Open Questions</a></li>
</ul>
</nav>
<p>For the safety verification of transition systems, we typically must perform some kind of <em>abstraction</em>. For finite transition systems, verification is theoretically decidable, but practically it suffers from the state space explosion problem, and so exhaustive verification may be hard (e.g. exponential) in general. So, for verifying any systems of non-trivial size, abstraction is typically necessary. Finding an inductive invariant to prove safety is, essentially, about finding a suitable abstraction that overapproximates the set of reachable system states. Furthermore, we presumably want this abstraction to be “concise" i.e. it doesn’t scale in proportion to the size of the transition system (e.g. the number of states).</p>
<section id="abstraction-domains" class="level2 unnumbered">
<h2 class="unnumbered">Abstraction Domains</h2>
<p>In general, in order to discover a “concise" inductive invariant we must work over some <em>abstraction domain</em>. Given a state space <span class="math inline">\(S\)</span>, we can define an abstraction domain <span class="math inline">\(D \subseteq 2^S\)</span> as simply a set of subsets of <span class="math inline">\(S\)</span>. For example, given the state space defined by a single real valued variable <span class="math inline">\(x \in \mathbb{R}\)</span>, a possible abstraction domain is <span class="math display">\[\begin{aligned}
    D_1 = \{x &gt; 2, x &lt; - 2\}\end{aligned}\]</span> where each element of <span class="math inline">\(D_1\)</span> is a subset of <span class="math inline">\(\mathbb{R}\)</span>, defined as a symbolic predicate over <span class="math inline">\(x\)</span>.</p>
<p>One way to define an abstraction domain for a state space <span class="math inline">\(S\)</span> is to explicitly define the set <span class="math inline">\(D \subseteq 2^S\)</span>. Alternatively, we can provide a set of atomic predicates and rules for for how these predicates can be combined to form additional predicates. Our abstraction domain is then defined as the space of all possible composite predicates that can be formed as combinations of atomic predicates, perhaps up to some bounded size. We can call this the <em>grammar-based</em> approach.</p>
<p>For example, for a state space <span class="math inline">\(S\)</span> we can define a <em>grammar</em> <span class="math inline">\(G\)</span> as a pair <span class="math inline">\((P,O)\)</span> where <span class="math inline">\(P \subseteq 2^S\)</span> is a set of predicates on <span class="math inline">\(S\)</span>, and <span class="math inline">\(O\)</span> is a set of operators for combining elements of <span class="math inline">\(P\)</span> to form new predicates on <span class="math inline">\(S\)</span>. These operators may be unary, binary, etc. For example, we may have a grammar <span class="math inline">\(G_1 = (\{x&gt;2, x &lt; 3\}, \{\neg, \vee\})\)</span>. In symbolic terms, the set <span class="math inline">\(O\)</span> could be composed of logical operators, but in general we can view <span class="math inline">\(O\)</span> as any set-based operators i.e. operators that take in some set of predicates of <span class="math inline">\(P\)</span> and produce new predicates in <span class="math inline">\(2^S\)</span>.</p>
<p>For transition systems with a state space <span class="math inline">\(S\)</span>, we can also always work over a “trivial” abstraction domain. That is, the domain <span class="math inline">\(D_{\bot} = \{\{s\} \mid s \in S\}\)</span> that consists of all “singleton" predicates i.e. those that contain a single concrete state. We can view this domain as “minimally abstract”, since the predicates don’t cover multiple states, and so don’t really perform any “true" abstraction.</p>
</section>
<section id="learning-inductive-invariants" class="level2 unnumbered">
<h2 class="unnumbered">Learning Inductive Invariants</h2>
<p>If we are given a transition system <span class="math inline">\(M\)</span> with reachable states <span class="math inline">\(Reach\)</span> and we want to prove that some invariant <span class="math inline">\(Safe\)</span> holds on <span class="math inline">\(M\)</span>, we must find an inductive invariant sufficient to establish <span class="math inline">\(Safe\)</span>. Typically, we search for an inductive invariant by iteratively strengthening <span class="math inline">\(Safe\)</span>, by conjoining a series of lemmas invariants: <span class="math display">\[\begin{aligned}
    &amp;\wedge Safe \\
    &amp;\wedge L_1 \\
    &amp;\phantom{\wedge}\vdots \\
    &amp;\wedge L_n\end{aligned}\]</span></p>
<p>One question, then, is how do we find suitable lemma invariants? One approach is to simply define an abstraction domain <span class="math inline">\(D\)</span> that consists of some large set of candidate invariants, and try to form an inductive invariant as the conjunction of these invariants. In practice, we may define <span class="math inline">\(D\)</span> using a grammar, but ultimately we are concerned with whether the abstraction domain generated by such a grammar is sufficient for learning an inductive invariant.</p>
<p>Following this approach to defining our abstraction domain, we now need a strategy for how to form an inductive invariant from the predicates in <span class="math inline">\(D\)</span> (which are simply “plain” invariants of our system <span class="math inline">\(M\)</span>). We also want to consider whether this strategy is guaranteed to converge to an inductive invariant, if one exists. By definition, we know that <span class="math inline">\(Reach\)</span> is always a valid inductive invariant, but for sake of a simple illustration, let’s also assume that there also exists one additional inductive invariant of our system, <span class="math inline">\(Ind\)</span> that is a strict superset of <span class="math inline">\(Reach\)</span> e.g. consider the following example:</p>
<div class="center">
<p><img src="invs1.png" style="width:70mm" alt="image" /></p>
</div>
<p>There are 3 invariants in our abstraction domain, <span class="math inline">\(D=\{L_1, L_2, L_3\}\)</span>, and two valid inductive invariants, <span class="math inline">\(Reach\)</span> and <span class="math inline">\(Ind\)</span>. If our strategy is to just select invariants from <span class="math inline">\(D\)</span> in some arbitrary order, are we guaranteed to converge to some inductive invariant? If we select <span class="math inline">\(L_1\)</span> and then <span class="math inline">\(L_2\)</span>, then we will converge to <span class="math inline">\(Ind\)</span>. But, if we select <span class="math inline">\(L_1\)</span> and then <span class="math inline">\(L_3\)</span>, we will end up with a resulting predicate <span class="math inline">\(L_1 \wedge L_3\)</span> that “overshoots" (i.e. is stronger than) <span class="math inline">\(Ind\)</span>, and we end up stuck, since there are no inductive invariants stronger than <span class="math inline">\(Ind\)</span> that are expressible in our abstraction domain. So, if we follow a strategy of strict refinement (always combining via conjunction), then we are inevitably stuck in this case. We could potentially undo a past choice, however, and try a different invariant selection strategy, in the style of a standard backtracking search. But, a question is how to detect when we end up in this "dead end" refinement scenario.</p>
</section>
<section id="other-techniques" class="level2 unnumbered">
<h2 class="unnumbered">Other Techniques</h2>
<p>Note that, at least in its initial versions, my understanding is that algorithms like IC3 were complete in the above sense (i.e. could always converge to an inductive invariant) because they essentially have the ability to always refine their abstraction to an arbitrarily fine-grained level i.e. they can just explicitly eliminate concrete states one by one (in the finite state case). This doesn’t really solve the problem, it just kind of works around it by degrading to explicit state enumeration if you can’t converge to a “concise" abstraction. When using the approach described above (i.e. our FMCAD approach), we fix the abstraction domain and if it is too coarse we don’t adjust it dynamically. IC3 originally worked in a somewhat differnet manner i.e. look at concrete counterexamples and then abstract based on them. I think they initially did this abstraction based on a “ternary simulation” approach i.e. given a concrete boolean state <span class="math display">\[\begin{aligned}
    &amp;\wedge x = 0 \\ 
    &amp;\wedge y = 0 \\ 
    &amp;\wedge z = 0\end{aligned}\]</span> look at all possible <span class="math inline">\(2^3\)</span> abstractions of this state that can be formed by dropping some subset of literals.</p>
</section>
<section id="open-questions" class="level2 unnumbered">
<h2 class="unnumbered">Open Questions</h2>
<ul>
<li><p>If you start off with a fixed abstraction domain, is there a way to dynamically adjust the domain if you realize that it cannot express the concepts (e.g. inductive invariants) you want to express? Is this basically similar to what CEGAR, abstraction refinement does? Also “widening”/“narrowing” in abstract interpretation?</p></li>
<li><p>If, in practical cases there are many inductive invariants in between the strongest and the weakest, does this make it much more unlikely that you will “overshoot” all of them and end up in a dead end? Even with a naive lemma selection approach, is it somehow quite likely you will converge on <em>one</em> of these inductive invariants?</p></li>
</ul>
</section>
</body>
</html>
