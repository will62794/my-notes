<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="William Schultz" />
  <meta name="author" content="William Schultz" />
  <title>Complexity Upper and Lower Bounds</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
  <link rel="stylesheet" href="../../style.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Complexity Upper and Lower Bounds</h1>
<p class="author">William Schultz</p>
<p class="author">William Schultz</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#bibliography">References</a></li>
</ul>
</nav>
<p>For any decision problem, we can establish both <em>upper bounds</em> and <em>lower bounds</em> on its complexity. Recall that a decision problem is formulated in terms of a language <span class="math inline">\(L\)</span>, consisting of a set of strings. The decision problem for a given language <span class="math inline">\(L\)</span> is to determine whether <span class="math inline">\(w \in L\)</span> for some given string <span class="math inline">\(w\)</span>.</p>
<p>An upper bound makes a statement about the maximum hardness/complexity of the problem, and a lower bound makes a statement about the minimum easiness of the problem. Establishing an upper bound is typically much easier, since you only need to provide a concrete algorithm that solves the problem in some worst case running time (i.e. show there exists an algorithm). Establishing a lower bound is generally much harder, since you need to show that there exists no algorithm that can solve the problem more efficiently than a certain complexity class (i.e. show no algorithm exists).</p>
<p>For example, one of the best known algorithms for 3-SAT as of 2019 has a numerical upper bound of something around <span class="math inline">\(O(1.307^n)\)</span> <span class="citation" data-cites="2019fasterkSAT">(<a href="#ref-2019fasterkSAT" role="doc-biblioref">Hansen et al. 2019</a>)</span>. There exists no known, general algorithm that can solve 3-SAT in polynomial time. But, it has also not been proven that such an algorithm doesn’t exist. It seems that the best known lower bounds for SAT sit somewhere in the polynomial range of <span class="math inline">\(n^{1.801}\)</span>, though this has some other caveats about “time-space tradeoffs” which I don’t fully understand <span class="citation" data-cites="SE3satlowerbounds">(<a href="#ref-SE3satlowerbounds" role="doc-biblioref"><span>“<span class="nocase">What are the best current lower bounds on 3SAT?</span>”</span> n.d.</a>)</span>. Proving that SAT, for example, had an exponential (or even super polynomial) lower bound would, of course, establish that <span class="math inline">\(P \neq NP\)</span>, since SAT is NP-complete, and this would serve to separate <span class="math inline">\(P\)</span> from <span class="math inline">\(NP\)</span>. Of course, one could also prove <span class="math inline">\(P=NP\)</span> by simply giving a polynomial time algorithm for SAT i.e. by dropping the upper bound from exponential to polynomial. This might be “easier”, in the sense that you would only have to find a single algorithm, but it may be “harder" in the sense that P=NP may not actually be true!</p>
<section id="bibliography" class="level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-2019fasterkSAT" class="csl-entry" role="doc-biblioentry">
Hansen, Thomas Dueholm, Haim Kaplan, Or Zamir, and Uri Zwick. 2019. <span>“<span class="nocase">Faster k-SAT Algorithms Using Biased-PPSZ</span>.”</span> In <em>Proceedings of the 51st Annual ACM SIGACT Symposium on Theory of Computing</em>, 578–89. STOC 2019. New York, NY, USA: Association for Computing Machinery. <a href="https://doi.org/10.1145/3313276.3316359">https://doi.org/10.1145/3313276.3316359</a>.
</div>
<div id="ref-SE3satlowerbounds" class="csl-entry" role="doc-biblioentry">
<span>“<span class="nocase">What are the best current lower bounds on 3SAT?</span>”</span> n.d. <a href="https://cstheory.stackexchange.com/questions/93/what-are-the-best-current-lower-bounds-on-3sat">https://cstheory.stackexchange.com/questions/93/what-are-the-best-current-lower-bounds-on-3sat</a>. <a href="https://cstheory.stackexchange.com/questions/93/what-are-the-best-current-lower-bounds-on-3sat">https://cstheory.stackexchange.com/questions/93/what-are-the-best-current-lower-bounds-on-3sat</a>.
</div>
</div>
</section>
</body>
</html>
