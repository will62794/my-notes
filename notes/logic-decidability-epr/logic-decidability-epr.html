<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="William Schultz" />
  <title>Notes on Logic, Decidability, EPR</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../../style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Notes on Logic, Decidability, EPR</h1>
<p class="author">William Schultz</p>
</header>
<h1 id="propositional-logic">Propositional Logic</h1>
<p>We define classic propositional logic <span class="citation" data-cites="2012benari"></span> as a formal system consisting of:</p>
<ul>
<li><p><span class="math inline">ùí´</span>: a countably infinite set of elements called <em>propositional symbols</em>. These are alternately referred to as <em>propositional variables</em>, <em>atomic propositions</em> or just <em>atoms</em>.</p></li>
<li><p><span class="math inline"><em>Œ©</em></span>: set of logical <em>operators</em> or <em>connectives</em>.</p></li>
</ul>
<p>For example, we traditionally have <span class="math inline"><em>Œ©</em>‚ÄÑ=‚ÄÑ{‚àß,‚à®,¬¨}</span>. A <em>formula</em> is defined as a sentence over propositional variables conjoined via the operators of <span class="math inline"><em>Œ©</em></span>. We can define the the set of syntactically valid formulas via a formal grammar. We let <span class="math inline">‚Ñ±</span> be the set of all such formulas.</p>
<p>For a formula <span class="math inline"><em>A</em>‚ÄÑ‚àà‚ÄÑ‚Ñ±</span>, where <span class="math inline">ùí´<sub><em>A</em></sub></span> is the set of atoms that appear in <span class="math inline"><em>A</em></span>, an <em>interpretation</em> for <span class="math inline"><em>A</em></span> is a total function <span class="math display">$$\begin{aligned}
    \mathcal{I}_A : {\mathcal{P}}_A \rightarrow \{True,False\}\end{aligned}$$</span> that assigns one of the <em>truth values</em>, <em>True</em> or <em>False</em>, to every atom in <span class="math inline">ùí´<sub><em>A</em></sub></span>. In other words, it‚Äôs just an assignment of boolean values to propositional variables. The truth value of a formula <span class="math inline"><em>A</em></span> <em>under</em> an interpretation <span class="math inline">‚Ñê<sub><em>A</em></sub></span>, denoted <span class="math inline"><em>v</em><sub>‚Ñê<sub><em>A</em></sub></sub>(<em>A</em>)</span>, is defined in the standard way. That is, just plug in the values for each propositional variable as given by the interpretation function <span class="math inline">‚Ñê<sub><em>A</em></sub></span> and then evaluate the formula according to the semantics of the standard logical connectives. Note that although this is the ‚Äúclassical‚Äù notion of intepretation for propositional logic, we could have a more general notion of intepretation that allows for an intepretation function <span class="math inline">‚Ñê‚ÄÑ:‚ÄÑùí´<sub><em>A</em></sub>‚ÄÑ‚Üí‚ÄÑ<em>D</em></span> that maps propositional symbols to some arbitrary domain of values. The logical connectives contained in <span class="math inline"><em>Œ©</em></span> must then also be given appropriate semantics in accordance. For example, three-valued, many-valued logic systems.</p>
<p>For a formula <span class="math inline"><em>A</em>‚ÄÑ‚àà‚ÄÑ‚Ñ±</span> we have the following definitions:</p>
<ul>
<li><p><span class="math inline"><em>A</em></span> is <em>satisfiable</em> iff <span class="math inline"><em>v</em><sub>‚Ñê<sub><em>A</em></sub></sub>(<em>A</em>)‚ÄÑ=‚ÄÑ<em>T</em><em>r</em><em>u</em><em>e</em></span> for <em>some</em> intepretation <span class="math inline">‚Ñê</span>. A satisfying intepretation is called a <em>model</em> for <span class="math inline"><em>A</em></span>.</p></li>
<li><p><span class="math inline"><em>A</em></span> is <em>valid</em> iff <span class="math inline"><em>v</em><sub>‚Ñê</sub>(<em>A</em>)‚ÄÑ=‚ÄÑ<em>T</em><em>r</em><em>u</em><em>e</em></span> for <em>all</em> intepretations <span class="math inline">‚Ñê</span>.</p></li>
<li><p><span class="math inline"><em>A</em></span> is <em>unsatisfiable</em> iff it is not satisfiable i.e. if <span class="math inline"><em>v</em><sub>‚Ñê</sub>(<em>A</em>)‚ÄÑ=‚ÄÑ<em>F</em><em>a</em><em>l</em><em>s</em><em>e</em></span> for <em>all</em> interpretations <span class="math inline">‚Ñê</span>.</p></li>
</ul>
<h2 id="decidability-and-complexity">Decidability and Complexity</h2>
<p>Determining any of the above properties for a propositional formula is a decidable problem, since we can easily enumerate the finite (exponentially many) number of possible intepretations for a formula to determine whether it is satisfiable/valid/unsatisfiable. The satisfiability problem for propositional formulas is known as the SAT problem, and is NP-complete. In some special cases satisfiability can be solved in polynomial time e.g. 2-SAT (where CNF clauses contain 2 variables) is in P. The 3-SAT problem is NP-complete.</p>
<p>Determining the validity of a propositional formula <span class="math inline"><em>œï</em>‚ÄÑ‚àà‚ÄÑ‚Ñ±</span> can be determined by checking the unsatisfiability of <span class="math inline">¬¨<em>œï</em></span>. That is, we check if there are any interpretations that violate <span class="math inline"><em>œï</em></span>. If there are none, then <span class="math inline"><em>œï</em></span> must be true under all interpretations i.e. <span class="math inline"><em>œï</em></span> is a tautology. The problem of checking validity/tautology of propositional formulas is co-NP-complete.</p>
<h2 id="logical-consequence-and-theories">Logical Consequence and Theories</h2>
<p>For a set of formulas <span class="math inline"><em>U</em>‚ÄÑ=‚ÄÑ{<em>A</em><sub>1</sub>,‚ÄÜ‚Ä¶}</span>, a <em>model</em> of <span class="math inline"><em>U</em></span> is an interpretation <span class="math inline">‚Ñê</span> such that <span class="math inline"><em>v</em><sub>‚Ñê</sub>(<em>A</em><sub><em>i</em></sub>)‚ÄÑ=‚ÄÑ<em>T</em><em>r</em><em>u</em><em>e</em></span> for all <span class="math inline"><em>A</em><sub><em>i</em></sub>‚ÄÑ‚àà‚ÄÑ<em>U</em></span>. For a given formula <span class="math inline"><em>A</em></span>, we say that <span class="math inline"><em>A</em></span> is a <em>logical consequence of U</em>, denoted <span class="math inline"><em>U</em>‚ÄÑ‚ä®‚ÄÑ<em>A</em></span>, iff every model of <span class="math inline"><em>U</em></span> is a model of <span class="math inline"><em>A</em></span>. That is, for any interpretation that is a model of <span class="math inline"><em>U</em></span>, it is also a model of <span class="math inline"><em>A</em></span>.</p>
<p>Let <span class="math inline"><em>U</em></span> be a set of formulas. We say that <span class="math inline"><em>U</em></span> is <em>closed under logical consequence</em> iff for all formulas <span class="math inline"><em>A</em></span>, if <span class="math inline"><em>U</em>‚ÄÑ‚ä®‚ÄÑ<em>A</em></span>, then <span class="math inline"><em>A</em>‚ÄÑ‚àà‚ÄÑ<em>U</em></span>. A set of formulas that is closed under logical consequence is called a <em>theory</em>. The elements of <span class="math inline"><em>U</em></span> are <em>theorems</em>. Theories are typically constructed by selecting a set of formulas called <em>axioms</em> and deducing their logical consequences. For a given set of formulas <span class="math inline"><em>U</em></span>, we say that <span class="math inline"><em>U</em></span> is <em>axiomatizable</em> iff there exists a set of formulas <span class="math inline"><em>X</em></span> such that <span class="math inline"><em>U</em>‚ÄÑ=‚ÄÑ{<em>A</em>‚ÄÖ‚à£‚ÄÖ<em>X</em>‚ÄÑ‚ä®‚ÄÑ<em>A</em>}</span>. That is, there exists a set of formulas <span class="math inline"><em>X</em></span> such that every formula in <span class="math inline"><em>U</em></span> can be deduced as a logical consequence of the formulas in <span class="math inline"><em>X</em></span>. The set of formulas <span class="math inline"><em>X</em></span> are the <em>axioms</em> of <span class="math inline"><em>U</em></span>. If <span class="math inline"><em>X</em></span> is finite, then <span class="math inline"><em>U</em></span> is said to be <em>finitely axiomatizable</em>.</p>
<h2 id="deductive-systems-and-proofs">Deductive Systems and Proofs</h2>
<p>Using a purely semantical approach to determining the validity of formulas in propositional logic can have various drawbacks. For example, not all logics have decision procedures like propositional logic. Thus, we can use an alternate, deductive approach.</p>
<p>A <em>deductive system</em> is a set of formulas called <em>axioms</em> and a set of <em>rules of inference</em>. A <em>proof</em> in a deductive system is a sequence of formulas <span class="math inline"><em>S</em>‚ÄÑ=‚ÄÑ{<em>A</em><sub>1</sub>,‚ÄÜ‚Ä¶,‚ÄÜ<em>A</em><sub><em>n</em></sub>}</span> such that each formula <span class="math inline"><em>A</em><sub><em>i</em></sub></span> is either an axiom or it can be inferred from previous formulas of the sequence <span class="math inline"><em>A</em><sub><em>j</em><sub>1</sub></sub>,‚ÄÜ‚Ä¶,‚ÄÜ<em>A</em><sub><em>j</em><sub><em>k</em></sub></sub></span>, using a rule of inference. For <span class="math inline"><em>A</em><sub><em>n</em></sub></span>, the last formula in the sequence,we say that <span class="math inline"><em>A</em><sub><em>n</em></sub></span> is a <em>theorem</em>, the sequence <span class="math inline"><em>S</em></span> is a <em>proof</em> of <span class="math inline"><em>A</em><sub><em>n</em></sub></span>, and <span class="math inline"><em>A</em><sub><em>n</em></sub></span> is <em>provable</em>, denoted <span class="math inline">‚ÄÑ‚ä¢‚ÄÑ<em>A</em><sub><em>n</em></sub></span>. Note that even if there is no decision procedure to discover a proof, it can be mechanically <em>checked</em> i.e. using a syntax based approach to check that each applied inference rule is valid.</p>
<p>Proving soundness and completeness of a deductive system <span class="math inline">ùíü</span> means showing that for any formula <span class="math inline"><em>A</em></span>, <span class="math display">$$\begin{aligned}
    \vDash A \iff \vdash A  \end{aligned}$$</span> for <span class="math inline">ùíü</span>. That is, if <span class="math inline"><em>A</em></span> is valid (in a semantical sense), then <span class="math inline"><em>A</em></span> is provable in <span class="math inline">ùíü</span>, and vice versa. A deductive system <span class="math inline">ùíü</span> is sound if any provable statement in <span class="math inline">ùíü</span> is a true statement i.e. if <span class="math inline">‚ÄÑ‚ä¢‚ÄÑ<em>A</em></span> then <span class="math inline">‚ÄÑ‚ä®‚ÄÑ<em>A</em></span>.</p>
<h2 id="resolution">Resolution</h2>
<p>The method of <em>resolution</em> is an efficient method for searching for a proof. More precisely, it is a decision procedure for unsatisfiability in propositional logic.</p>
<p>Assume we have a propositional formula given in <em>clausal form</em>, which is basically just conjunctive normal form (CNF) where each clause is viewed as a set of literals. This representation doesn‚Äôt discard any essential information from the CNF representation, since a CNF formula is a conjunction of clauses, and the order doesn‚Äôt matter for either the overall conjunction or the disjunctions within each clause. For example, the following formula in CNF <span class="math display">$$\begin{aligned}
    (a \vee b) \wedge (b \vee \neg c \vee b)\end{aligned}$$</span> is written in clausal form as <span class="math display">$$\begin{aligned}
    \{\{a,b\},\{b,\neg c\}\}\end{aligned}$$</span> A clause is <em>trivial</em> if it contains a pair of clashing literals i.e. if it contains both a literal and its negation. That is, <span class="math inline">(<em>x</em>‚à®¬¨<em>x</em>)‚ÄÑ‚áî‚ÄÑ<em>T</em><em>r</em><em>u</em><em>e</em></span>, so <span class="math inline">{<em>x</em>,‚ÄÜ¬¨<em>x</em>}</span> can always be removed from a clause without changing the truth value of the clause. We consider the empty clause to be unsatisfiable, and denote it as <span class="math inline">‚ñ´</span>. We consider the empty set of clauses, <span class="math inline">‚àÖ</span>. to be valid.</p>
<p>Now, we say that two clauses <span class="math inline"><em>C</em><sub>1</sub>,‚ÄÜ<em>C</em><sub>2</sub></span> are <em>clashing</em> if there are literals <span class="math inline"><em>l</em>‚ÄÑ‚àà‚ÄÑ<em>C</em><sub>1</sub></span> and <span class="math inline"><em>l</em><sup><em>c</em></sup>‚ÄÑ‚àà‚ÄÑ<em>C</em><sub>2</sub></span>, where <span class="math inline"><em>l</em><sup><em>c</em></sup></span> is the complement of the literal <span class="math inline"><em>l</em></span> (i.e. if <span class="math inline"><em>l</em>‚ÄÑ=‚ÄÑ<em>p</em></span>, then <span class="math inline"><em>l</em><sup><em>c</em></sup>‚ÄÑ=‚ÄÑ<em>pÃÑ</em></span>). We say that <span class="math inline"><em>C</em><sub>1</sub>,‚ÄÜ<em>C</em><sub>2</sub></span> <em>clash on</em> the pair of literals <span class="math inline"><em>l</em>,‚ÄÜ<em>l</em><sup><em>c</em></sup></span>. We define the <em>resolvent</em> of <span class="math inline"><em>C</em><sub>1</sub></span> and <span class="math inline"><em>C</em><sub>2</sub></span> as the clause <span class="math display">$$\begin{aligned}
Res(C_1,C_2) = (C_1 - \{l\}) \cup (C_2 - \{l^c\})    \end{aligned}$$</span> and <span class="math inline"><em>C</em><sub>1</sub></span> and <span class="math inline"><em>C</em><sub>2</sub></span> are the <em>parent clauses</em> of <span class="math inline"><em>C</em></span>. That is, the resolvent <span class="math inline"><em>C</em></span> is produced by removing <span class="math inline"><em>l</em></span> and <span class="math inline"><em>l</em><sup><em>c</em></sup></span> from their respective clauses <span class="math inline"><em>C</em><sub>1</sub>,‚ÄÜ<em>C</em><sub>2</sub></span>, and then taking the union of the two resulting clauses.</p>
<p>For example, the clauses <span class="math inline"><em>C</em><sub>1</sub>‚ÄÑ=‚ÄÑ<em>a</em><em>b</em><em>cÃÑ</em></span> and <span class="math inline"><em>C</em><sub>2</sub>‚ÄÑ=‚ÄÑ<em>b</em><em>c</em><em>eÃÑ</em></span> clash on the pair of literals <span class="math inline"><em>c</em></span> and <span class="math inline"><em>cÃÑ</em></span>. The resolvent is <span class="math display">$$\begin{aligned}
    Res(C_1,C_2) &amp;= (ab\bar{c} - \{\bar{c}\}) \cup (bc\bar{e} - \{c\})\\
    &amp;=ab \cup b\bar{e}\\
    &amp;=ab\bar{e}\\
    &amp;=\{a,b,\bar{e}\}\end{aligned}$$</span></p>
<p>Note that resolution is only performed if the pair of clauses clash on <em>exactly</em> one pair of complementary literals. The important thing to note is that the resolvent <span class="math inline"><em>C</em></span> is satisfiable iff the parent clauses <span class="math inline"><em>C</em><sub>1</sub></span> and <span class="math inline"><em>C</em><sub>2</sub></span> are both satisfiable. Thus, the resolution procedure then basically proceeds by taking in a set of clauses <span class="math inline"><em>S</em></span> and repeatedly applying this resolution rule. That is</p>
<ul>
<li><p>Choose a pair of clashing clauses <span class="math inline">{<em>C</em><sub>1</sub>,‚ÄÜ<em>C</em><sub>2</sub>}‚ÄÑ‚äÜ‚ÄÑ<em>S</em><sub><em>i</em></sub></span> that has not been chosen before.</p></li>
<li><p>Compute <span class="math inline"><em>R</em><em>e</em><em>s</em>(<em>C</em><sub>1</sub>,<em>C</em><sub>2</sub>)</span>.</p></li>
<li><p>If <span class="math inline"><em>C</em></span> is not a trivial clause, let <span class="math inline"><em>S</em><sub><em>i</em>‚ÄÖ+‚ÄÖ1</sub>‚ÄÑ=‚ÄÑ<em>S</em><sub><em>i</em></sub>‚ÄÖ‚à™‚ÄÖ{<em>C</em>}</span>. Otherwise <span class="math inline"><em>S</em><sub><em>i</em>‚ÄÖ+‚ÄÖ1</sub>‚ÄÑ=‚ÄÑ<em>S</em><sub><em>i</em></sub></span>.</p></li>
<li><p>Terminate the procedure if either:</p>
<ul>
<li><p><span class="math inline"><em>C</em>‚ÄÑ=‚ÄÑ‚ñ´</span></p></li>
<li><p>All pairs of clashing clauses have been resolved.</p></li>
</ul></li>
</ul>
<p>See Figure <a href="#fig:resolution-refutation-tree" data-reference-type="ref" data-reference="fig:resolution-refutation-tree">1</a> for an example of a resolution proof for the clause set <span class="math inline"><em>S</em>‚ÄÑ=‚ÄÑ{<em>p</em>,‚ÄÜ<em>pÃÑ</em><em>q</em>,‚ÄÜ<em>rÃÑ</em>,‚ÄÜ<em>pÃÑ</em><em>qÃÑ</em><em>r</em>}</span> where the rule applications are represented as a tree, leading to the unsatisfiable clause.</p>
<p><img src="figures/refutation-example.png" id="fig:resolution-refutation-tree" alt="image" /> <span id="fig:resolution-refutation-tree" label="fig:resolution-refutation-tree">[fig:resolution-refutation-tree]</span></p>
<h1 id="first-order-logic">First Order Logic</h1>
<p><em>First order logic</em> extends propositional logic to include quantification over some specified domain, in addition to a more general notion of <em>interpretation</em> for a given formula.</p>
<p>In order to define the structure of first order formulas, we first define the following:</p>
<ul>
<li><p><span class="math inline">ùí´</span>: a countable set of <em>predicate symbols</em> (alternately <em>relation symbols</em>)</p></li>
<li><p><span class="math inline">ùíú</span>: a countable set of <em>constant symbols</em>.</p></li>
<li><p><span class="math inline">ùí±</span>: a countable set of <em>variables</em>.</p></li>
</ul>
<p>The sets of predicate and constant symbols, <span class="math inline">(ùí´,ùíú)</span>, are also collectively referred to as the <em>signature</em> of a first order logic. Each predicate symbol <span class="math inline"><em>p</em><sup><em>n</em></sup>‚ÄÑ‚àà‚ÄÑùí´</span> has an arity, which is the number <span class="math inline"><em>n</em>‚ÄÑ‚â•‚ÄÑ1</span> of <em>arguments</em> that it takes. Note that these predicate symbols are merely syntactic objects i.e. they are <em>not</em> relations, semantically. Rather, they are given semantics under an <em>interpretation</em> (described below), which assigns a relation of the proper arity to each predicate symbol. Note that we can optionally augment the above list to include <em>function symbols</em>, which also have a specified arity similar to <em>predicate symbols</em>, but it is not necessary to give a basic definition of first order logic. This extension to function symbols is also discussed below.</p>
<p>An <em>atomic formula</em> of first order logic is an <span class="math inline"><em>n</em></span>-ary predicate followed by a list of <span class="math inline"><em>n</em></span> arguments <span class="math inline"><em>p</em>(<em>t</em><sub>1</sub>,‚Ä¶,<em>t</em><sub><em>n</em></sub>)</span>, where each argument <span class="math inline"><em>t</em><sub><em>i</em></sub></span> is either a variable or a constant. A <em>formula</em> of first order logic is defined as strings generated by the following grammar: <span class="math display">$$\begin{aligned}
    &amp;argument&amp; &amp;::= x \qquad &amp;\text{for any } x\in \mathcal{V}\\
    &amp;argument&amp; &amp;::= a \qquad &amp;\text{for any } a\in \mathcal{A}\\
    &amp;argument\_list&amp; &amp;::= argument\\
    &amp;argument\_list&amp; &amp;::= argument,argument\_list\\
    &amp;atomic\_formula&amp; &amp;::= p(argument\_list) \qquad &amp;\text{for any $n$-ary } p\in \mathcal{P}\\
    \\
    &amp;formula&amp; &amp;::= atomic\_formula\\
    &amp;formula&amp; &amp;::= \neg \, formula\\
    &amp;formula&amp; &amp;::= formula \vee formula\\
    &amp;formula&amp; &amp;::= \exists x \, formula \qquad &amp;\text{for any } x \in \mathcal{V}\\
    &amp;formula&amp; &amp;::= \forall x \, formula \qquad &amp;\text{for any } x \in \mathcal{V}\end{aligned}$$</span> Note that for a formula <span class="math inline"><em>A</em></span>, an occurrence of a variable <span class="math inline"><em>x</em></span> in <span class="math inline"><em>A</em></span> is a <em>free variable</em> of <span class="math inline"><em>A</em></span> iff <span class="math inline"><em>x</em></span> is not within the scope of a quantified variable. A variable which is not free is <em>bound</em>. If a formula has no free variables, it is <em>closed</em>.</p>
<h2 id="interpretations">Interpretations</h2>
<p>In propositional logic, an interpretation is a mapping from atomic propositions (i.e. propositional variables) to truth values (i.e. <span class="math inline">{<em>T</em><em>r</em><em>u</em><em>e</em>,‚ÄÜ<em>F</em><em>a</em><em>l</em><em>s</em><em>e</em>}</span>). In first order logic, the analogous concept is a mapping from atomic formulas to truth values. The atomic formulas of first order logic, however, contain variables and constants that must be assigned elements of some domain. In propositional logic, each atomic proposition is assumed to be boolean-valued, so this is not a concern. That is, the ‚Äúdomain‚Äù of each propositional variable is implicitly assumed to be the truth values <span class="math inline">{<em>T</em><em>r</em><em>u</em><em>e</em>,‚ÄÜ<em>F</em><em>a</em><em>l</em><em>s</em><em>e</em>}</span>. In first order logic, this is generalized by allowing variables to range over specified domains.</p>
<p>Let <span class="math inline"><em>A</em></span> be a formula of first order logic where <span class="math inline">{<em>p</em><sub>1</sub>,‚ÄÜ‚Ä¶,‚ÄÜ<em>p</em><sub><em>m</em></sub>}</span> are all the predicates appearing in <span class="math inline"><em>A</em></span> and <span class="math inline">{<em>a</em><sub>1</sub>,‚ÄÜ‚Ä¶,‚ÄÜ<em>a</em><sub><em>k</em></sub>}</span> are all the constants appearing in <span class="math inline"><em>A</em></span>. An <em>interpretation</em> <span class="math inline">‚Ñê<sub><em>A</em></sub></span> for a formula <span class="math inline"><em>A</em></span> is a triple consisting of the following:</p>
<ul>
<li><p><span class="math inline"><em>D</em></span>: a <em>non-empty</em> set called the <em>domain</em></p></li>
<li><p><span class="math inline">{<em>R</em><sub>1</sub>,‚ÄÜ‚Ä¶,‚ÄÜ<em>R</em><sub><em>m</em></sub>}</span>: a set of relations on <span class="math inline"><em>D</em></span>, where <span class="math inline"><em>R</em><sub><em>i</em></sub></span> is an <span class="math inline"><em>n</em><sub><em>i</em></sub></span>-ary relation on <span class="math inline"><em>D</em></span> (that is, <span class="math inline"><em>R</em><sub><em>i</em></sub>‚ÄÑ‚äÜ‚ÄÑ<em>D</em><sup><em>n</em><sub><em>i</em></sub></sup></span>) assigned to the <span class="math inline"><em>n</em><sub><em>i</em></sub></span>-ary predicate symbol <span class="math inline"><em>p</em><sub><em>i</em></sub></span>.</p></li>
<li><p><span class="math inline">{<em>d</em><sub>1</sub>,‚ÄÜ‚Ä¶,‚ÄÜ<em>d</em><sub><em>k</em></sub>}</span>: a set of constant values, where <span class="math inline"><em>d</em><sub><em>i</em></sub>‚ÄÑ‚àà‚ÄÑ<em>D</em></span> is assigned to the constant <span class="math inline"><em>a</em><sub><em>i</em></sub></span>.</p></li>
</ul>
<p>In other words, an interpretation defines a ‚Äúdomain of discourse‚Äù <span class="math inline"><em>D</em></span>, along with a concrete assignment of relations to each predicate symbol <span class="math inline"><em>p</em>‚ÄÑ‚àà‚ÄÑùí´</span> and values from the domain to each constant <span class="math inline"><em>a</em>‚ÄÑ‚àà‚ÄÑùíú</span>.</p>
<p>For example, if we have <span class="math display">$$\begin{aligned}
    \mathcal{P} &amp;= \{p\}\\
    \mathcal{A} &amp;= \{a\}\\
    \mathcal{V} &amp;= \{x\}\end{aligned}$$</span> then a first order formula may look like: <span class="math display">$$\begin{aligned}
    \forall x p(a,x)\end{aligned}$$</span> which might contain the following various interpretations: <span class="math display">$$\begin{aligned}
    \mathcal{I}_1 = (\mathbb{N},\{\leq\},\{0\})\qquad 
    \mathcal{I}_2 = (\mathbb{N},\{\leq\},\{1\})\qquad
    \mathcal{I}_3 = (\mathbb{Z},\{\leq\},\{0\})\end{aligned}$$</span> where the domain is either the natural numbers, <span class="math inline">‚Ñï</span>, or the integers, <span class="math inline">‚Ñ§</span>, and the binary relation <span class="math inline">‚â§</span> is assigned to the binary predicate symbol <span class="math inline"><em>p</em></span>, and either 0 or 1 assigned to the constant <span class="math inline"><em>a</em></span>. We could also have an interpretation over strings e.g. <span class="math display">$$\begin{aligned}
    \mathcal{I}_4 = (Str, \{isPrefix\}, \{``s"\})\end{aligned}$$</span> where <span class="math inline"><em>S</em><em>t</em><em>r</em></span> represents the set of all strings, <span class="math inline"><em>i</em><em>s</em><em>P</em><em>r</em><em>e</em><em>f</em><em>i</em><em>x</em></span> is the binary relation determining if one string is a prefix of another, and ‚Äús‚Äù is a single character string. This illustrates that the same first order logic formulas can be ‚Äúimbued‚Äù (i.e. <em>interpreted</em>) with various semantics. Furthermore, for an interpretation <span class="math inline">‚Ñê<sub><em>A</em></sub></span> and formula <span class="math inline"><em>A</em></span>, an <em>assignment</em> <span class="math inline"><em>œÉ</em><sub>‚Ñê<sub><em>A</em></sub></sub>‚ÄÑ:‚ÄÑùí±‚ÄÑ‚Üí‚ÄÑ<em>D</em></span> is a function that maps every free variable <span class="math inline"><em>v</em>‚ÄÑ‚àà‚ÄÑùí±</span> to an element <span class="math inline"><em>d</em>‚ÄÑ‚àà‚ÄÑ<em>D</em></span>, the domain of <span class="math inline">‚Ñê<sub><em>A</em></sub></span>.</p>
<p>For a closed formula <span class="math inline"><em>A</em></span> (no free variables), the <em>truth value</em> of <span class="math inline"><em>A</em></span> under <span class="math inline">‚Ñê<sub><em>A</em></sub></span>, denoted <span class="math inline"><em>v</em><sub>‚Ñê<sub><em>A</em></sub></sub>(<em>A</em>)</span>, is given by ‚Äúevaluating‚Äù the formula in the standard way. That is, evaluating the inner, unquantified formula over each element in the domain, for each quantified variable, plugging into the predicates of the formula and evaluating. We can define these evaluation semantics formally but it is mostly straightforward. For example, the truth value of the closed formula <span class="math display">$$\begin{aligned}
    \forall x \, p(a,x)\end{aligned}$$</span> under the interpretation <span class="math display">$$\begin{aligned}
    \mathcal{I}_1 = (\{0,1\},\{\leq\},\{0\})\qquad \end{aligned}$$</span> evaluates to <span class="math inline"><em>T</em><em>r</em><em>u</em><em>e</em></span> iff <span class="math inline">0‚ÄÑ‚â§‚ÄÑ<em>x</em></span> for all <span class="math inline"><em>x</em>‚ÄÑ‚àà‚ÄÑ{0,‚ÄÜ1}</span>.</p>
<p>Now we define the following for a closed formula <span class="math inline"><em>A</em></span> of first order logic:</p>
<ul>
<li><p><span class="math inline"><em>A</em></span> is <em>true</em> in <span class="math inline">‚Ñê</span> (alternately, <span class="math inline">‚Ñê</span> is a <em>model</em> for <span class="math inline"><em>A</em></span>) iff <span class="math inline"><em>v</em><sub>‚Ñê</sub>(<em>A</em>)‚ÄÑ=‚ÄÑ<em>T</em><em>r</em><em>u</em><em>e</em></span>. We denote this as <span class="math inline">‚Ñê‚ÄÑ‚ä®‚ÄÑ<em>A</em></span>.</p></li>
<li><p><span class="math inline"><em>A</em></span> is <em>valid</em> if for all interpretations <span class="math inline">‚Ñê</span>, <span class="math inline">‚Ñê‚ÄÑ‚ä®‚ÄÑ<em>A</em></span></p></li>
<li><p><span class="math inline"><em>A</em></span> is <em>satisfiable</em> if for some interpretation <span class="math inline">‚Ñê</span>, <span class="math inline">‚Ñê‚ÄÑ‚ä®‚ÄÑ<em>A</em></span></p></li>
<li><p><span class="math inline"><em>A</em></span> is <em>unsatisfiable</em> if it is not satisfiable.</p></li>
</ul>
<p>Note that these definitions of validity/satisfiability are a bit more involved than in the case of propositional logic. We must consider a formula under <em>all possible interpretations</em> in order to consider validity. For satisfiability, we may only need to find one adequate interpretation, though we may need to consider/search through many possible interpretations.</p>
<h2 id="sec:fol-with-functions">Functions</h2>
<p>Our definition above for defining the structure of first order formulas did not allow for the inclusion of functions i.e. we only allowed predicate symbols. We can generalize this to allow for functions in our first order formulas. Adding functions basically augments the set <span class="math inline">(ùí´,ùíú,ùí±)</span> of <em>predicate symbols</em>, <em>constant symbols</em>, and <em>variables</em>, with a set <span class="math inline">‚Ñ±</span> of <em>function symbols</em>, each with a specified arity, as with predicate symbols. The notion of an <em>interpretation</em> of a formula is thus also augmented, to become a 4-tuple <span class="math display">$$\begin{aligned}
    \mathcal{I} = (D, \{R_1,\dots, R_k\},  \{F_1^{n_1},\dots, F_l^{n_l}\}, \{d_1,\dots,d_k\})\end{aligned}$$</span> where each <span class="math inline"><em>F</em><sub><em>j</em></sub><sup><em>n</em><sub><em>j</em></sub></sup></span> is an <span class="math inline"><em>n</em><sub><em>j</em></sub></span>-ary function on <span class="math inline"><em>D</em></span> that is assigned to the function symbol <span class="math inline"><em>f</em><sub><em>j</em></sub><sup><em>n</em><sub><em>j</em></sub></sup></span>, with the rest of the semantics essentially unchanged. The grammar of formulas is also updated to account for functions, which produce a value in the domain <span class="math inline"><em>D</em></span>, rather than a truth value, as predicates do. Note that if we allow for function symbols, then we can simply view constants as functions of arity 0.</p>
<h2 id="many-sorted-first-order-logic">Many Sorted First Order Logic</h2>
<p>In standard first order logic, interpretations are over a single domain <span class="math inline"><em>D</em></span>. Many-sorted logic generalizes this to allow for multiple domains, referred to as <em>sorts</em> <span class="citation" data-cites="2014manysortedlogic"></span>. That is, a signature is augmented to include a set of <em>sorts</em>, where the arity of each predicate, constant, and/or function symbol now also includes the sort of each of its arguments. An interpretation consists of a triple <span class="math display">$$\begin{aligned}
    (\{D_1,\dots,D_n\}, \{R_1,\dots, R_m\},\{d_1,\dots,d_k\})\end{aligned}$$</span> where <span class="math inline">{<em>D</em><sub>1</sub>,‚ÄÜ‚Ä¶,‚ÄÜ<em>D</em><sub><em>n</em></sub>}</span> are domains assigned to each <em>sort</em>.</p>
<p>There is also a notion of <em>stratification</em> of sorts i.e. a total order on all sorts. This is made use of in Ivy <span class="citation" data-cites="2020ivymultimodal"></span> and also discussed in prior work <span class="citation" data-cites="2007decidablefragmentsmanysorted 2009completeinstant"></span>. Sorted first order logic is the basic formalism used, for example, in the original Ivy paper <span class="citation" data-cites="padon2016ivy"></span> that described their modeling language. It is also used as the encoding for TLA+ in TLAPS <span class="citation" data-cites="2016merzmanysorted"></span>.</p>
<h2 id="pcnf-and-clausal-form">PCNF and Clausal Form</h2>
<p>In propositional logic, a formula is in conjunctive normal form (CNF) if it is a conjunct of clauses (where a clause is a disjunction of literals). A notational variant of CNF is <em>clausal form</em> i.e. a formula is represented as a set of clauses, where each clause is a set of literals.</p>
<p>We generalize CNF to first order logic by defining a normal form that accounts for quantifiers. We say that a formula is in <em>PCNF</em> (<em>prenex conjunctive normal form</em>) iff it is of the form: <span class="math display">$$\begin{aligned}
    Q_1 x_1 \dots Q_n x_n \, M\end{aligned}$$</span> where <span class="math inline"><em>Q</em><sub><em>i</em></sub></span> are quantifiers and <span class="math inline"><em>M</em></span> is a quantifier-free formula in CNF (conjunctive normal form). The sequence <span class="math inline"><em>Q</em><sub>1</sub><em>x</em><sub>1</sub>‚Ä¶<em>Q</em><sub><em>n</em></sub><em>x</em><sub><em>n</em></sub></span> is the <em>prefix</em> and <span class="math inline"><em>M</em></span> is the <em>matrix</em>. Also, let <span class="math inline"><em>A</em></span> be a closed formula in PCNF whose prefix consists only of universal quantifiers. The <em>clausal form</em> of <span class="math inline"><em>A</em></span> consists of the matrix of <span class="math inline"><em>A</em></span> written as a set of clauses.</p>
<h3 id="skolemization">Skolemization</h3>
<p>In propositional logic, every formula can be translated to an equivalent one in CNF, but this is not the case in first order logic. We can, however, transform a formula in first order logic into one in clausal form (i.e. one with only universal quantifiers) without modifying its satisfiability. That is, formally, if <span class="math inline"><em>A</em></span> is a closed formula, then there exists a formula <span class="math inline"><em>A</em>‚Ä≤</span> in clausal form such that <span class="math inline"><em>A</em>‚ÄÑ‚âà‚ÄÑ<em>A</em>‚Ä≤</span>, where <span class="math inline">‚âà</span> denotes the equisatisfiability relation. That is, <span class="math inline"><em>A</em></span> is satisfiable iff <span class="math inline"><em>A</em>‚Ä≤</span> is. Note that this does not mean that <span class="math inline"><em>A</em></span> and <span class="math inline"><em>A</em>‚Ä≤</span> are logically equivalent. The process of transforming <span class="math inline"><em>A</em></span> into such a form <span class="math inline"><em>A</em>‚Ä≤</span> is referred to as <em>Skolemization</em>. That is, a formula is in <em>Skolem normal form</em> if it is in prenex normal form with only universal quantifiers.</p>
<p>It is straightforward to first transform <span class="math inline"><em>A</em></span> into a logically equivalent formula in PCNF. The removal of existential quantifiers is the main challenge. The basic idea of Skolemization can be illustrated in an example formula <span class="math display">$$\begin{aligned}
    \forall x \exists y p(x,y)\end{aligned}$$</span> Intuitively, we think of reading the quantifiers as ‚Äúfor all <span class="math inline"><em>x</em></span>, find a <span class="math inline"><em>y</em></span> associated with <span class="math inline"><em>x</em></span> such that the predicate <span class="math inline"><em>p</em></span> is true‚Äù. This basically matches the intuitive concept of a function. That is, we want a function <span class="math inline"><em>f</em></span> such that <span class="math inline"><em>y</em>‚ÄÑ=‚ÄÑ<em>f</em>(<em>x</em>)</span>. So, the existential quantifier can be removed giving <span class="math inline"><em>A</em>‚Ä≤‚ÄÑ=‚ÄÑ‚àÄ<em>x</em><em>p</em>(<em>x</em>,<em>f</em>(<em>x</em>))</span>.</p>
<h2 id="sec:finite-models">Finite Models</h2>
<p>We say that a set of formulas <span class="math inline"><em>U</em>‚ÄÑ=‚ÄÑ{<em>A</em><sub>1</sub>,‚ÄÜ‚Ä¶}</span> is <em>satisfiable</em> iff there exists an interpretation <span class="math inline">‚Ñê<sub><em>U</em></sub></span> such that <span class="math inline"><em>v</em><sub>‚Ñê<sub><em>U</em></sub></sub>(<em>A</em><sub><em>i</em></sub>)‚ÄÑ=‚ÄÑ<em>T</em><em>r</em><em>u</em><em>e</em></span> for all <span class="math inline"><em>i</em></span>. The satisfying interpretation is a <em>model</em> for <span class="math inline"><em>U</em></span>.</p>
<p>A set of formulas <span class="math inline"><em>U</em></span> has the <em>finite model property</em> iff: <span class="math inline"><em>U</em></span> is satisfiable iff it is satisfiable in an interpretation whose domain is a finite set. As one example, let <span class="math inline"><em>U</em></span> be the set of pure formulas of the form <span class="math display">$$\begin{aligned}
    \exists x_1 \dots \exists x_k \forall y_1 \dots \forall y_l \, A(x_1,\dots,x_k,y_1,\dots,y_l)\end{aligned}$$</span> where <span class="math inline"><em>A</em></span> is quantifier free. Then <span class="math inline"><em>U</em></span> has the finite model property.</p>
<p>Another interesting fact is one due to L√∂wenheim-Skolem, which says that if a formula of first order logic is satisfiable, then it is satisfiable in a countable domain (Theorem 12.10 in <span class="citation" data-cites="2012benari"></span>). Thus, countable domains (e.g. the natural numbers) are sufficient for interpretation of first order logic.</p>
<h2 id="decidability">Decidability</h2>
<p>Checking validity of a formula in first order logic is undecidable. Even under particular, fixed interpretations, checking validity may be undecidable. For example, Peano arithmetic, which consists of a single constant symbol <span class="math inline">0</span>, a function symbol <span class="math inline"><em>s</em></span> representing the successor function, and two binary function symbols, <span class="math inline">+</span> and <span class="math inline">*</span>, is undecidable. In addition, a theorem of Trakhtenbrot gives a further refinement. It states that even if we consider first order logic over only the class of finite models, then validity and satisfiability are both still undecidable <span class="citation" data-cites="libkin2004elements"></span>.</p>
<p>Note that Lowenheim‚Äôs theorem (Section <a href="#sec:finite-models" data-reference-type="ref" data-reference="sec:finite-models">2.5</a>) establishes that any satisfiable formula in first order logic is satisfiable in an interpretation with a countable domain. Trakhtenbrot‚Äôs theorem is in some sense complementary to this result, since it states that even if we consider only interpretations with finite domains, the validity problem in first order logic is still fundamentally hard i.e. undecidable.</p>
<h3 id="decidable-classes">Decidable Classes</h3>
<p>There are, however, interpretations under which validity in first order logic is decidable. The theory of Presburger arithmetic, which includes addition but omits multiplication, is decidable. In addition, checking validity of formulas in <em>monadic predicate calculus</em> are also decidable <span class="citation" data-cites="lewis1980complexity"></span>. This is a fragment of first order logic in which all relation symbols are <em>monadic</em> i.e. they take only one argument, and there are no function symbols. That is, all atomic formulas are of the form <span class="math inline"><em>P</em>(<em>x</em>)</span>, where <span class="math inline"><em>P</em></span> is a relation symbol and <span class="math inline"><em>x</em></span> is a variable.</p>
<p>Other decidable cases of first order logic can be defined by the structure of quantifier prefix. We define a formula of first order logic as <em>pure</em> if it contains no function symbols (including constants which are 0-ary function symbols). There are decision procedures for the validity of pure PCNF formulas whose quantifier prefixes are of one of the following forms: <span class="math display">$$\begin{aligned}
    &amp;\forall x_1\dots\forall x_n \,\exists x_1\dots\exists x_n \\
    &amp;\forall x_1\dots\forall x_n \, \exists y \, \forall z_1\dots\forall z_m \\
    &amp;\forall x_1\dots\forall x_n \, \exists y_1 \exists y_2 \, \forall z_1\dots\forall z_m \end{aligned}$$</span> which are abbreviated as <span class="math inline">‚àÄ<sup>*</sup>‚àÉ<sup>*</sup></span>, <span class="math inline">‚àÄ<sup>*</sup>‚àÉ‚àÄ<sup>*</sup></span>, <span class="math inline">‚àÄ<sup>*</sup>‚àÉ‚àÉ‚àÄ<sup>*</sup></span> <span class="citation" data-cites="Dreben1979TheDP"></span>.</p>
<p>Note that if validity is decidable for a class of formulas, then we can always check if a formula <span class="math inline"><em>œï</em></span> in this class is satisfiable by checking if <span class="math inline">¬¨<em>œï</em></span> is valid, and applying the following simple rule: <span class="math display">$$\begin{aligned}
    &amp;\neg \phi \text{ is valid} \Rightarrow \phi \text{ is not satisfiable}\\
    &amp;\neg \phi \text{ is not valid} \Rightarrow \phi \text{ is satisfiable}\end{aligned}$$</span> Recall that if <span class="math inline">¬¨<em>œï</em></span> is valid this means that there are <em>no</em> satisfying interpretations for <span class="math inline"><em>œï</em></span>. Thus, <span class="math inline"><em>œï</em></span> is unsatisfiable. If <span class="math inline">¬¨<em>œï</em></span> is not valid, then this means there must be some interpretations that do not satisfy <span class="math inline">¬¨<em>œï</em></span>, meaning <span class="math inline"><em>œï</em></span> must be satisfiable.</p>
<p>Note that if <em>satisfiability</em> is decidable for a class of formulas <span class="math inline"><em>F</em></span>, then validity should be decidable for the <em>negation</em> of formulas in that class. That is, for any <span class="math inline"><em>œï</em>‚ÄÑ‚àà‚ÄÑ<em>F</em></span>, if checking <span class="math inline"><em>S</em><em>A</em><em>T</em>(<em>œï</em>)</span> is decidable, then we can check validity of <span class="math inline"><em>œï</em></span> by checking <span class="math inline"><em>U</em><em>N</em><em>S</em><em>A</em><em>T</em>(¬¨<em>œï</em>)</span>, but <span class="math inline">¬¨<em>œï</em></span> may no longer fall into the decidable class <span class="math inline"><em>F</em></span>. So, if SAT is decidable for a formula class <span class="math inline"><em>F</em></span>, then for any <span class="math inline"><em>œï</em>‚ÄÑ‚àà‚ÄÑ<em>F</em></span>, we know validity is decidable for <span class="math inline">¬¨<em>œï</em></span>, since we can check validity as <span class="math inline"><em>U</em><em>N</em><em>S</em><em>A</em><em>T</em>(¬¨(¬¨<em>œï</em>))‚ÄÑ=‚ÄÑ<em>U</em><em>N</em><em>S</em><em>A</em><em>T</em>(<em>œï</em>)</span>, which is decidable since SAT for <span class="math inline"><em>œï</em></span> is decidable.</p>
<h4 id="epr">EPR</h4>
<p>For the so-called <em>Bernays-Sch√∂nfinkel class</em>, consisting of pure formulas (no function symbols) with prefixes of the form <span class="math inline">‚àÉ<sup>*</sup>‚àÄ<sup>*</sup></span>, satisfiability is decidable <span class="citation" data-cites="lewis1980complexity"></span>. This class is alternately referred to as <em>EPR</em> (<strong>e</strong>ffectively <strong>pr</strong>opositional), since it can be effectively translated into propositional logic formulas by a process of grounding or instantiation. That is, satisfiability for EPR formulas can be reduced to SAT by first replacing all existential variables by Skolem constants, and then grounding the universally quantified variables by all combinations of constants. This process produces a propositional formula that is exponentially larger than the original <span class="citation" data-cites="demoura2008deciding"></span>.</p>
</body>
</html>
