@techreport{lamport1974on,
author = {Lamport, Leslie},
title = {On Self-stabilizing Systems},
year = {1974},
month = {December},
abstract = {This note was written upon reading Dijkstra's classic paper "Self-stabilizing Systems in Spite of Distributed Control" that appeared in the November 1974 issue of CACM (see [58]). It generalizes one of the algorithms in Dijkstra's paper from a line of processes to an arbitrary tree of processes. It also discusses the self-stabilizing properties of the bakery algorithm. I never tried to publish this note--probably because I regarded it as too small a piece of work to be worth a paper by itself.
The note contains the intriguing sentence: "There is a complicated modified version of the bakery algorithm in which the values of all variables are bounded." I never wrote down that version, and I'm not sure what I had in mind. But I think I was thinking of roughly the following modification. As a process waits to enter its critical section, it keeps reducing its number, not entering the critical section until its number equals one. A process p can reduce its number by at most one, and only when the next lower-numbered process's number is at least two less than p's number, and the next higher-numbered process is within one of p's number. I think I intended to use the techniques of [25] to allow reading and writing of numbers to remain non-atomic while maintaining the order of waiting processes. (If eventually all processes stop changing their numbers, then all processes will eventually read the correct numbers, allowing some process to progress.) At one time, I convinced myself that this algorithm is correct. But I never wrote a rigorous proof, so I don't know if it really works. Filling in the details and proving correctness should be a nice exercise.},
url = {https://www.microsoft.com/en-us/research/publication/self-stabilizing-systems/},
number = {CA 7412-0511},
}
@inproceedings{hance2021finding,
  title={Finding Invariants of Distributed Systems: It's a Small (Enough) World After All.},
  author={Hance, Travis and Heule, Marijn and Martins, Ruben and Parno, Bryan},
  booktitle={NSDI},
  pages={115--131},
  year={2021}
}
@inproceedings{goel2021symmetry,
  title={On Symmetry and Quantification: A New Approach to Verify Distributed Protocols},
  author={Goel, Aman and Sakallah, Karem},
  booktitle={NASA Formal Methods Symposium},
  pages={131--150},
  year={2021},
  organization={Springer}
}
@inproceedings{yao2021distai,
  title={DistAI: Data-Driven Automated Invariant Learning for Distributed Protocols},
  author={Yao, Jianan and Tao, Runzhou and Gu, Ronghui and Nieh, Jason and Jana, Suman and Ryan, Gabriel},
  booktitle={15th $\{$USENIX$\}$ Symposium on Operating Systems Design and Implementation ($\{$OSDI$\}$ 21)},
  pages={405--421},
  year={2021}
}
@article{goel2021towards,
  title={Towards an Automatic Proof of Lamport's Paxos},
  author={Goel, Aman and Sakallah, Karem A},
  journal={arXiv preprint arXiv:2108.08796},
  year={2021}
}
@article{mirzaie2020parameterized,
  title={Parameterized synthesis of self-stabilizing protocols in symmetric networks},
  author={Mirzaie, Nahal and Faghih, Fathiyeh and Jacobs, Swen and Bonakdarpour, Borzoo},
  journal={Acta Informatica},
  volume={57},
  number={1},
  pages={271--304},
  year={2020},
  publisher={Springer}
}
@inproceedings{lamport2005real,
  title={Real-time model checking is really simple},
  author={Lamport, Leslie},
  booktitle={Advanced Research Working Conference on Correct Hardware Design and Verification Methods},
  pages={162--175},
  year={2005},
  organization={Springer}
}
@misc{paxosuniqueproposalSOquestion,
  title={why does paxos proposalId need to be unique},
  publisher={StackOverflow},
  howpublished={https://stackoverflow.com/questions/45610160/why-does-paxos-proposalid-need-to-be-unique}
}
@inproceedings{padon2016ivy,
  title={Ivy: safety verification by interactive generalization},
  author={Padon, Oded and McMillan, Kenneth L and Panda, Aurojit and Sagiv, Mooly and Shoham, Sharon},
  booktitle={Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages={614--630},
  year={2016}
}
@article{albarghouthi2016maximal,
  title={Maximal specification synthesis},
  author={Albarghouthi, Aws and Dillig, Isil and Gurfinkel, Arie},
  journal={ACM SIGPLAN Notices},
  volume={51},
  number={1},
  pages={789--801},
  year={2016},
  publisher={ACM New York, NY, USA}
}
@inproceedings{zhang2020behavioral,
  title={A behavioral notion of robustness for software systems},
  author={Zhang, Changjian and Garlan, David and Kang, Eunsuk},
  booktitle={Proceedings of the 28th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
  pages={1--12},
  year={2020}
}
@InProceedings{howard_flex_paxos,
  author =	{Heidi Howard and Dahlia Malkhi and Alexander Spiegelman},
  title =	{{Flexible Paxos: Quorum Intersection Revisited}},
  booktitle =	{20th International Conference on Principles of Distributed Systems (OPODIS 2016)},
  pages =	{25:1--25:14},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-031-6},
  ISSN =	{1868-8969},
  year =	{2017},
  volume =	{70},
  editor =	{Panagiota Fatourou and Ernesto Jim{\'e}nez and Fernando Pedone},
  publisher =	{Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{http://drops.dagstuhl.de/opus/volltexte/2017/7094},
  URN =		{urn:nbn:de:0030-drops-70947},
  doi =		{10.4230/LIPIcs.OPODIS.2016.25},
  annote =	{Keywords: Paxos, Distributed Consensus, Quorums}
}
@inproceedings{lopes2014weakest,
  title={Weakest precondition synthesis for compiler optimizations},
  author={Lopes, Nuno P and Monteiro, Jos{\'e}},
  booktitle={International Conference on Verification, Model Checking, and Abstract Interpretation},
  pages={203--221},
  year={2014},
  organization={Springer}
}
@inproceedings{black2000mutation,
  title={Mutation operators for specifications},
  author={Black, Paul E and Okun, Vadim and Yesha, Yaacov},
  booktitle={Proceedings ASE 2000. Fifteenth IEEE International Conference on Automated Software Engineering},
  pages={81--88},
  year={2000},
  organization={IEEE}
}
@article{bonakdarpour2012automated,
  title={Automated model repair for distributed programs},
  author={Bonakdarpour, Borzoo and Kulkarni, Sandeep S},
  journal={ACM SIGACT News},
  volume={43},
  number={2},
  pages={85--107},
  year={2012},
  publisher={ACM New York, NY, USA}
}
@inproceedings{chaouch2009reduction,
  title={A reduction theorem for the verification of round-based distributed algorithms},
  author={Chaouch-Saad, Mouna and Charron-Bost, Bernadette and Merz, Stephan},
  booktitle={International Workshop on Reachability Problems},
  pages={93--106},
  year={2009},
  organization={Springer}
}
@inproceedings{2019fasterkSAT,
author = {Hansen, Thomas Dueholm and Kaplan, Haim and Zamir, Or and Zwick, Uri},
title = {{Faster k-SAT Algorithms Using Biased-PPSZ}},
year = {2019},
isbn = {9781450367059},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3313276.3316359},
doi = {10.1145/3313276.3316359},
abstract = {The PPSZ algorithm, due to Paturi, Pudlak, Saks and Zane, is currently the fastest known algorithm for the k-SAT problem, for every k&gt;3. For 3-SAT, a tiny improvement over PPSZ was obtained by Hertli. We introduce a biased version of the PPSZ algorithm using which we obtain an improvement over PPSZ for every k≥ 3. For k=3 we also improve on Herli’s result and get a much more noticeable improvement over PPSZ, though still relatively small. In particular, for Unique 3-SAT, we improve the current bound from 1.308n to 1.307n.},
booktitle = {Proceedings of the 51st Annual ACM SIGACT Symposium on Theory of Computing},
pages = {578–589},
numpages = {12},
keywords = {randomized algorithm, satisfiability},
location = {Phoenix, AZ, USA},
series = {STOC 2019}
}
@misc{SE3satlowerbounds,
title={{What are the best current lower bounds on 3SAT?}},
url={https://cstheory.stackexchange.com/questions/93/what-are-the-best-current-lower-bounds-on-3sat},
howpublished = "\url{https://cstheory.stackexchange.com/questions/93/what-are-the-best-current-lower-bounds-on-3sat}",
}
@book{sipser2015,
author = {Sipser, Michael},
title = {Introduction to the Theory of Computation},
year = {1996},
isbn = {053494728X},
publisher = {International Thomson Publishing},
edition = {1st},
abstract = {From the Publisher:Michael Sipser's philosophy in writing this book is simple: make the subject interesting and relevant, and the students will learn. His emphasis on unifying computer science theory - rather than offering a collection of low-level details - sets the book apart, as do his intuitive explanations. Throughout the book, Sipser - a noted authority on the theory of computation - builds students' knowledge of conceptual tools used in computer science, the aesthetic sense they need to create elegant systems, and the ability to think through problems on their own. INTRODUCTION TO THE THEORY OF COMPUTATION provides a mathematical treatment of computation theory grounded in theorems and proofs. Proofs are presented with a "proof idea" component to reveal the concepts underpinning the formalism. Algorithms are presented using prose instead of pseudocode to focus attention on the algorithms themselves, rather than on specific computational models. Topic coverage, terminology, and order of presentation are traditional for an upper-level course in computer science theory. Users of the Preliminary Edition (now out of print) will be interested to note several new chapters on complexity theory: Chapter 8 on space complexity; Chapter 9 on provable intractability, and Chapter 10 on advanced topics, including approximation algorithms, alternation, interactive proof systems, cryptography, and parallel computing.}
}
@book{2021Ebbinghaus,
abstract = {This textbook introduces first-order logic and its role in the foundations of mathematics by examining fundamental questions. What is a mathematical proof? How can mathematical proofs be justified? Are there limitations to provability? To what extent can machines carry out mathematical proofs? In answering these questions, this textbook explores the capabilities and limitations of algorithms and proof methods in mathematics and computer science. The chapters are carefully organized, featuring complete proofs and numerous examples throughout. Beginning with motivating examples, the book goes on to present the syntax and semantics of first-order logic. After providing a sequent calculus for this logic, a Henkin-type proof of the completeness theorem is given. These introductory chapters prepare the reader for the advanced topics that follow, such as Gödel's Incompleteness Theorems, Trakhtenbrot's undecidability theorem, Lindström's theorems on the maximality of first-order logic, and results linking logic with automata theory. This new edition features many modernizations, as well as two additional important results: The decidability of Presburger arithmetic, and the decidability of the weak monadic theory of the successor function. Mathematical Logic is ideal for students beginning their studies in logic and the foundations of mathematics. Although the primary audience for this textbook will be graduate students or advanced undergraduates in mathematics or computer science, in fact the book has few formal prerequisites. It demands of the reader only mathematical maturity and experience with basic abstract structures, such as those encountered in discrete mathematics or algebra.},
author = {Ebbinghaus, Heinz-Dieter},
address = {Cham, Switzerland},
edition = {Third edition.},
isbn = {9783030738396},
keywords = {Logic, Symbolic and mathematical},
language = {eng},
publisher = {Springer},
series = {Graduate texts in mathematics},
title = {Mathematical logic},
year = {2021},
}
@inbook{2012benari,
author = {Ben-Ari, M.},
address = {London},
edition = {3rd ed.},
isbn = {9781447141297},
keywords = {Logic, Symbolic and mathematical},
language = {eng},
publisher = {Springer},
title = {Mathematical logic for computer science},
year = {2012},
chapter={7},
}
@inproceedings{Dreben1979TheDP,
  title={The decision problem: Solvable classes of quantificational formulas},
  author={Burton Dreben and Warren D. Goldfarb},
  year={1979}
}
@article{lewis1980complexity,
  title={{Complexity results for classes of quantificational formulas}},
  author={Lewis, Harry R},
  journal={Journal of Computer and System Sciences},
  volume={21},
  number={3},
  pages={317--353},
  year={1980},
  publisher={Elsevier}
}
@techreport{demoura2008deciding,
author = {de Moura, Leonardo and Piskac, Ruzica and Bjørner, Nikolaj},
title = {{Deciding Effectively Propositional Logic using DPLL and Substitution Sets}},
year = {2008},
month = {August},
abstract = {We introduce a DPLL calculus that is a decision procedure for the Bernays-Schoenfinkel class, also known as EPR. Our calculus allows combining techniques for efficient propositional search with data-structures, such as Binary Decision Diagrams, that can efficiently and succinctly encode finite sets of substitutions and operations on these. In the calculus, clauses comprise of a sequence of literals together with a finite set of substitutions; truth assignments are also represented using substitution sets. The calculus works directly at the level of sets, and admits performing simultaneous constraint propagation and decisions, resulting in potentially exponential speedups over existing approaches.},
publisher = {Springer-Verlag},
url = {https://www.microsoft.com/en-us/research/publication/deciding-effectively-propositional-logic-using-dpll-and-substitution-sets/},
pages = {21},
number = {MSR-TR-2008-104},
}
@InProceedings{2016merzmanysorted,
author="Merz, Stephan
and Vanzetto, Hern{\'a}n",
editor="Butler, Michael
and Schewe, Klaus-Dieter
and Mashkoor, Atif
and Biro, Miklos",
title="Encoding TLA+ into Many-Sorted First-Order Logic",
booktitle="Abstract State Machines, Alloy, B, TLA, VDM, and Z",
year="2016",
publisher="Springer International Publishing",
address="Cham",
pages="54--69",
isbn="978-3-319-33600-8"
}
@InProceedings{2007decidablefragmentsmanysorted,
author="Abadi, Aharon
and Rabinovich, Alexander
and Sagiv, Mooly",
editor="Dershowitz, Nachum
and Voronkov, Andrei",
title="Decidable Fragments of Many-Sorted Logic",
booktitle="Logic for Programming, Artificial Intelligence, and Reasoning",
year="2007",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="17--31",
abstract="We investigate the possibility of developing a decidable logic which allows expressing a large variety of real world specifications. The idea is to define a decidable subset of many-sorted (typed) first- order logic. The motivation is that types simplify the complexity of mixed quantifiers when they quantify over different types. We noticed that many real world verification problems can be formalized by quantifying over different types in such a way that the relations between types remain simple.",
isbn="978-3-540-75560-9"
}
@InProceedings{2020ivymultimodal,
author="McMillan, Kenneth L.
and Padon, Oded",
editor="Lahiri, Shuvendu K.
and Wang, Chao",
title="Ivy: A Multi-modal Verification Tool for Distributed Algorithms",
booktitle="Computer Aided Verification",
year="2020",
publisher="Springer International Publishing",
address="Cham",
pages="190--202",
abstract="Ivy is a multi-modal verification tool for correct design and implementation of distributed protocols and algorithms, supporting modular specification, implementation and proof. Ivy supports proving safety and liveness properties of parameterized and infinite-state systems via three modes: deductive verification using an SMT solver, abstraction and model checking, and manual proofs using natural deduction. It supports light-weight formal methods via compositional specification-based testing and bounded model checking. Ivy can extract executable distributed programs by translation to efficient C++ code. It is designed to support decidable automated reasoning, to improve proof stability and to provide transparency in the case of proof failures. For this purpose, it presents concrete finite counterexamples, automatically audits proofs for decidability of verification conditions, and provides modular hiding of theories.",
isbn="978-3-030-53291-8"
}
@InProceedings{2009completeinstant,
author="Ge, Yeting
and de Moura, Leonardo",
editor="Bouajjani, Ahmed
and Maler, Oded",
title="Complete Instantiation for Quantified Formulas in Satisfiabiliby Modulo Theories",
booktitle="Computer Aided Verification",
year="2009",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="306--320",
abstract="Quantifier reasoning in Satisfiability Modulo Theories (SMT) is a long-standing challenge. The practical method employed in modern SMT solvers is to instantiate quantified formulas based on heuristics, which is not refutationally complete even for pure first-order logic. We present several decidable fragments of first order logic modulo theories. We show how to construct models for satisfiable formulas in these fragments. For richer undecidable fragments, we discuss conditions under which our procedure is refutationally complete. We also describe useful heuristics based on model checking for prioritizing or avoiding instantiations.",
isbn="978-3-642-02658-4"
}
@misc{2014manysortedlogic,
title="Many-sorted logic",
author="Jouko Vaananen",
year="2014",
url={http://www.math.helsinki.fi/logic/opetus/msl/ILLC_MSL_2014.1.pdf},
howpublished={\url{http://www.math.helsinki.fi/logic/opetus/msl/ILLC_MSL_2014.1.pdf}},
}
@article{1986kozen,
author = {Apt, K R and Kozen, D C},
title = {Limits for Automatic Verification of Finite-State Concurrent Systems},
year = {1986},
issue_date = {May 30,1986},
publisher = {Elsevier North-Holland, Inc.},
address = {USA},
volume = {22},
number = {6},
issn = {0020-0190},
url = {https://doi.org/10.1016/0020-0190(86)90071-2},
doi = {10.1016/0020-0190(86)90071-2},
journal = {Inf. Process. Lett.},
month = {may},
pages = {307–309},
numpages = {3}
}
@article{1997clarkenetwork,
author = {Clarke, E. M. and Grumberg, O. and Jha, S.},
title = {Verifying Parameterized Networks},
year = {1997},
issue_date = {Sept. 1997},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {19},
number = {5},
issn = {0164-0925},
url = {https://doi.org/10.1145/265943.265960},
doi = {10.1145/265943.265960},
abstract = {This article describes a technique based on network grammars and abstraction to verify families of state-transition systems. The family of state-transition systems is represented by a context-free network grammar. Using the structure of the network grammar our technique constructs a process invariant that simulates all the state-transition systems in the family. A novel idea introduced in this article is the use of regular languages to express state properties. We have implemented our techniques and verified two nontrivial examples.},
journal = {ACM Trans. Program. Lang. Syst.},
month = {sep},
pages = {726–750},
numpages = {25},
keywords = {parameterized systems, temporal logic, model checking, process invariants}
}
@book{libkin2004elements,
  title={Elements of finite model theory},
  author={Libkin, Leonid},
  volume={41},
  year={2004},
  publisher={Springer}
}
@Inbook{Kroening2016,
author="Kroening, Daniel
and Strichman, Ofer",
title="Quantified Formulas",
bookTitle="Decision Procedures: An Algorithmic Point of View",
year="2016",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="199--227",
abstract="Quantification allows us to specify the extent of validity of a predicate, the domain in which the predicate should hold. The syntactic element used in the logic for specifying quantification is called a quantifier.",
isbn="978-3-662-50497-0",
doi="10.1007/978-3-662-50497-0_9",
url="https://doi.org/10.1007/978-3-662-50497-0_9"
}
@inproceedings{1977cousot,
author = {Cousot, Patrick and Cousot, Radhia},
title = {Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints},
year = {1977},
isbn = {9781450373500},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/512950.512973},
doi = {10.1145/512950.512973},
abstract = {A program denotes computations in some universe of objects. Abstract interpretation of programs consists in using that denotation to describe computations in another universe of abstract objects, so that the results of abstract execution give some information on the actual computations. An intuitive example (which we borrow from Sintzoff [72]) is the rule of signs. The text -1515 * 17 may be understood to denote computations on the abstract universe {(+), (-), (±)} where the semantics of arithmetic operators is defined by the rule of signs. The abstract execution -1515 * 17 → -(+) * (+) → (-) * (+) → (-), proves that -1515 * 17 is a negative number. Abstract interpretation is concerned by a particular underlying structure of the usual universe of computations (the sign, in our example). It gives a summary of some facets of the actual executions of a program. In general this summary is simple to obtain but inaccurate (e.g. -1515 + 17 → -(+) + (+) → (-) + (+) → (±)). Despite its fundamentally incomplete results abstract interpretation allows the programmer or the compiler to answer questions which do not need full knowledge of program executions or which tolerate an imprecise answer, (e.g. partial correctness proofs of programs ignoring the termination problems, type checking, program optimizations which are not carried in the absence of certainty about their feasibility, …).},
booktitle = {Proceedings of the 4th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
pages = {238–252},
numpages = {15},
location = {Los Angeles, California},
series = {POPL '77}
}

@Inbook{Dams2018,
author="Dams, Dennis
and Grumberg, Orna",
editor="Clarke, Edmund M.
and Henzinger, Thomas A.
and Veith, Helmut
and Bloem, Roderick",
title="Abstraction and Abstraction Refinement",
bookTitle="Handbook of Model Checking",
year="2018",
publisher="Springer International Publishing",
address="Cham",
pages="385--419",
abstract="Abstraction, in the context of model checking, is aimed at reducing the state space of the system by omitting details that are irrelevant to the property being verified. Many successful approaches to the ``state explosion problem,'' some of them described in other chapters, can be seen as abstractions. In this chapter, several notions of abstraction are considered in a uniform setting. Different such notions lead to a variety of preservation results that establish which kind of temporal properties may be verified via an abstracted system. We first define the needed background on simulation and bisimulation relations and their logic preservation. We then present the abstraction that is currently most widely used in practice: existential abstraction, which preserves universal fragments of branching-time logics. We give examples of such abstractions: localization reduction for hardware and predicate abstraction for software. We then proceed to stronger abstractions which preserve full branching-time logics. We introduce Kripke Modal Transition Systems and modal simulation, and show logic preservation. We close the chapter with a review of the presented results in the light of the notion of completeness.",
isbn="978-3-319-10575-8",
doi="10.1007/978-3-319-10575-8_13",
url="https://doi.org/10.1007/978-3-319-10575-8_13"
}
@inproceedings{2003abswithoutcex,
author = {McMillan, Kenneth L. and Amla, Nina},
title = {Automatic Abstraction without Counterexamples},
year = {2003},
isbn = {3540008985},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {A method of automatic abstraction is presented that uses proofs of unsatisfiability derived from SAT-based bounded model checking as a guide to choosing an abstraction for unbounded model checking. Unlike earlier methods, this approach is not based on analysis of abstract counterexamples. The performance of this approach on benchmarks derived from microprocessor verification indicates that SAT solvers are quite effective in eliminating logic that is not relevant to a given property. Moreover, benchmark results suggest that when bounded model checking successfully terminates, and the problem is unsatisfiable, the number of state variables in the proof of unsatisfiability tends to be small. In almost all cases tested, when bounded model checking succeeded, unbounded model checking of the resulting abstraction also succeeded.},
booktitle = {Proceedings of the 9th International Conference on Tools and Algorithms for the Construction and Analysis of Systems},
pages = {2–17},
numpages = {16},
location = {Warsaw, Poland},
series = {TACAS'03}
}
@article{94mcabs,
author = {Clarke, Edmund M. and Grumberg, Orna and Long, David E.},
title = {Model Checking and Abstraction},
year = {1994},
issue_date = {Sept. 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {5},
issn = {0164-0925},
url = {https://doi.org/10.1145/186025.186051},
doi = {10.1145/186025.186051},
abstract = {We describe a method for using abstraction to reduce the complexity of temporal-logic model checking. Using techniques similar to those involved in abstract interpretation, we construct an abstract model of a program without ever examining the corresponding unabstracted model. We show how this abstract model can be used to verify properties of the original program. We have implemented a system based on these techniques, and we demonstrate their practicality using a number of examples, including a program representing a pipelined ALU circuit with over 101300 states.},
journal = {ACM Trans. Program. Lang. Syst.},
month = {sep},
pages = {1512–1542},
numpages = {31},
keywords = {temporal logic, abstract interpretation, model checking, binary decision diagrams (BDDs)}
}
@InProceedings{2003satinterp,
author="McMillan, K. L.",
editor="Hunt, Warren A.
and Somenzi, Fabio",
title="Interpolation and SAT-Based Model Checking",
booktitle="Computer Aided Verification",
year="2003",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="1--13",
abstract="We consider a fully SAT-based method of unbounded symbolic model checking based on computing Craig interpolants. In benchmark studies using a set of large industrial circuit verification instances, this method is greatly more efficient than BDD-based symbolic model checking, and compares favorably to some recent SAT-based model checking methods on positive instances.",
isbn="978-3-540-45069-6"
}

