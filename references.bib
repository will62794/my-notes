@techreport{lamport1974on,
author = {Lamport, Leslie},
title = {On Self-stabilizing Systems},
year = {1974},
month = {December},
abstract = {This note was written upon reading Dijkstra's classic paper "Self-stabilizing Systems in Spite of Distributed Control" that appeared in the November 1974 issue of CACM (see [58]). It generalizes one of the algorithms in Dijkstra's paper from a line of processes to an arbitrary tree of processes. It also discusses the self-stabilizing properties of the bakery algorithm. I never tried to publish this note--probably because I regarded it as too small a piece of work to be worth a paper by itself.
The note contains the intriguing sentence: "There is a complicated modified version of the bakery algorithm in which the values of all variables are bounded." I never wrote down that version, and I'm not sure what I had in mind. But I think I was thinking of roughly the following modification. As a process waits to enter its critical section, it keeps reducing its number, not entering the critical section until its number equals one. A process p can reduce its number by at most one, and only when the next lower-numbered process's number is at least two less than p's number, and the next higher-numbered process is within one of p's number. I think I intended to use the techniques of [25] to allow reading and writing of numbers to remain non-atomic while maintaining the order of waiting processes. (If eventually all processes stop changing their numbers, then all processes will eventually read the correct numbers, allowing some process to progress.) At one time, I convinced myself that this algorithm is correct. But I never wrote a rigorous proof, so I don't know if it really works. Filling in the details and proving correctness should be a nice exercise.},
url = {https://www.microsoft.com/en-us/research/publication/self-stabilizing-systems/},
number = {CA 7412-0511},
}
@inproceedings{hance2021finding,
  title={Finding Invariants of Distributed Systems: It's a Small (Enough) World After All.},
  author={Hance, Travis and Heule, Marijn and Martins, Ruben and Parno, Bryan},
  booktitle={NSDI},
  pages={115--131},
  year={2021}
}
@inproceedings{goel2021symmetry,
  title={On Symmetry and Quantification: A New Approach to Verify Distributed Protocols},
  author={Goel, Aman and Sakallah, Karem},
  booktitle={NASA Formal Methods Symposium},
  pages={131--150},
  year={2021},
  organization={Springer}
}
@inproceedings{yao2021distai,
  title={DistAI: Data-Driven Automated Invariant Learning for Distributed Protocols},
  author={Yao, Jianan and Tao, Runzhou and Gu, Ronghui and Nieh, Jason and Jana, Suman and Ryan, Gabriel},
  booktitle={15th $\{$USENIX$\}$ Symposium on Operating Systems Design and Implementation ($\{$OSDI$\}$ 21)},
  pages={405--421},
  year={2021}
}
@article{goel2021towards,
  title={Towards an Automatic Proof of Lamport's Paxos},
  author={Goel, Aman and Sakallah, Karem A},
  journal={arXiv preprint arXiv:2108.08796},
  year={2021}
}
@article{mirzaie2020parameterized,
  title={Parameterized synthesis of self-stabilizing protocols in symmetric networks},
  author={Mirzaie, Nahal and Faghih, Fathiyeh and Jacobs, Swen and Bonakdarpour, Borzoo},
  journal={Acta Informatica},
  volume={57},
  number={1},
  pages={271--304},
  year={2020},
  publisher={Springer}
}
@inproceedings{lamport2005real,
  title={Real-time model checking is really simple},
  author={Lamport, Leslie},
  booktitle={Advanced Research Working Conference on Correct Hardware Design and Verification Methods},
  pages={162--175},
  year={2005},
  organization={Springer}
}
@misc{paxosuniqueproposalSOquestion,
  title={why does paxos proposalId need to be unique},
  publisher={StackOverflow},
  howpublished={https://stackoverflow.com/questions/45610160/why-does-paxos-proposalid-need-to-be-unique}
}
@inproceedings{padon2016ivy,
  title={Ivy: safety verification by interactive generalization},
  author={Padon, Oded and McMillan, Kenneth L and Panda, Aurojit and Sagiv, Mooly and Shoham, Sharon},
  booktitle={Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages={614--630},
  year={2016}
}
@article{albarghouthi2016maximal,
  title={Maximal specification synthesis},
  author={Albarghouthi, Aws and Dillig, Isil and Gurfinkel, Arie},
  journal={ACM SIGPLAN Notices},
  volume={51},
  number={1},
  pages={789--801},
  year={2016},
  publisher={ACM New York, NY, USA}
}
@inproceedings{zhang2020behavioral,
  title={A behavioral notion of robustness for software systems},
  author={Zhang, Changjian and Garlan, David and Kang, Eunsuk},
  booktitle={Proceedings of the 28th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
  pages={1--12},
  year={2020}
}
@InProceedings{howard_flex_paxos,
  author =	{Heidi Howard and Dahlia Malkhi and Alexander Spiegelman},
  title =	{{Flexible Paxos: Quorum Intersection Revisited}},
  booktitle =	{20th International Conference on Principles of Distributed Systems (OPODIS 2016)},
  pages =	{25:1--25:14},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-031-6},
  ISSN =	{1868-8969},
  year =	{2017},
  volume =	{70},
  editor =	{Panagiota Fatourou and Ernesto Jim{\'e}nez and Fernando Pedone},
  publisher =	{Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{http://drops.dagstuhl.de/opus/volltexte/2017/7094},
  URN =		{urn:nbn:de:0030-drops-70947},
  doi =		{10.4230/LIPIcs.OPODIS.2016.25},
  annote =	{Keywords: Paxos, Distributed Consensus, Quorums}
}
@inproceedings{lopes2014weakest,
  title={Weakest precondition synthesis for compiler optimizations},
  author={Lopes, Nuno P and Monteiro, Jos{\'e}},
  booktitle={International Conference on Verification, Model Checking, and Abstract Interpretation},
  pages={203--221},
  year={2014},
  organization={Springer}
}
@inproceedings{black2000mutation,
  title={Mutation operators for specifications},
  author={Black, Paul E and Okun, Vadim and Yesha, Yaacov},
  booktitle={Proceedings ASE 2000. Fifteenth IEEE International Conference on Automated Software Engineering},
  pages={81--88},
  year={2000},
  organization={IEEE}
}
@article{bonakdarpour2012automated,
  title={Automated model repair for distributed programs},
  author={Bonakdarpour, Borzoo and Kulkarni, Sandeep S},
  journal={ACM SIGACT News},
  volume={43},
  number={2},
  pages={85--107},
  year={2012},
  publisher={ACM New York, NY, USA}
}
@inproceedings{chaouch2009reduction,
  title={A reduction theorem for the verification of round-based distributed algorithms},
  author={Chaouch-Saad, Mouna and Charron-Bost, Bernadette and Merz, Stephan},
  booktitle={International Workshop on Reachability Problems},
  pages={93--106},
  year={2009},
  organization={Springer}
}
@inproceedings{2019fasterkSAT,
author = {Hansen, Thomas Dueholm and Kaplan, Haim and Zamir, Or and Zwick, Uri},
title = {{Faster k-SAT Algorithms Using Biased-PPSZ}},
year = {2019},
isbn = {9781450367059},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3313276.3316359},
doi = {10.1145/3313276.3316359},
abstract = {The PPSZ algorithm, due to Paturi, Pudlak, Saks and Zane, is currently the fastest known algorithm for the k-SAT problem, for every k&gt;3. For 3-SAT, a tiny improvement over PPSZ was obtained by Hertli. We introduce a biased version of the PPSZ algorithm using which we obtain an improvement over PPSZ for every k≥ 3. For k=3 we also improve on Herli’s result and get a much more noticeable improvement over PPSZ, though still relatively small. In particular, for Unique 3-SAT, we improve the current bound from 1.308n to 1.307n.},
booktitle = {Proceedings of the 51st Annual ACM SIGACT Symposium on Theory of Computing},
pages = {578–589},
numpages = {12},
keywords = {randomized algorithm, satisfiability},
location = {Phoenix, AZ, USA},
series = {STOC 2019}
}
@misc{SE3satlowerbounds,
title={{What are the best current lower bounds on 3SAT?}},
url={https://cstheory.stackexchange.com/questions/93/what-are-the-best-current-lower-bounds-on-3sat},
howpublished = "\url{https://cstheory.stackexchange.com/questions/93/what-are-the-best-current-lower-bounds-on-3sat}",
}
@book{sipser2015,
author = {Sipser, Michael},
title = {Introduction to the Theory of Computation},
year = {1996},
isbn = {053494728X},
publisher = {International Thomson Publishing},
edition = {1st},
abstract = {From the Publisher:Michael Sipser's philosophy in writing this book is simple: make the subject interesting and relevant, and the students will learn. His emphasis on unifying computer science theory - rather than offering a collection of low-level details - sets the book apart, as do his intuitive explanations. Throughout the book, Sipser - a noted authority on the theory of computation - builds students' knowledge of conceptual tools used in computer science, the aesthetic sense they need to create elegant systems, and the ability to think through problems on their own. INTRODUCTION TO THE THEORY OF COMPUTATION provides a mathematical treatment of computation theory grounded in theorems and proofs. Proofs are presented with a "proof idea" component to reveal the concepts underpinning the formalism. Algorithms are presented using prose instead of pseudocode to focus attention on the algorithms themselves, rather than on specific computational models. Topic coverage, terminology, and order of presentation are traditional for an upper-level course in computer science theory. Users of the Preliminary Edition (now out of print) will be interested to note several new chapters on complexity theory: Chapter 8 on space complexity; Chapter 9 on provable intractability, and Chapter 10 on advanced topics, including approximation algorithms, alternation, interactive proof systems, cryptography, and parallel computing.}
}
@book{2021Ebbinghaus,
abstract = {This textbook introduces first-order logic and its role in the foundations of mathematics by examining fundamental questions. What is a mathematical proof? How can mathematical proofs be justified? Are there limitations to provability? To what extent can machines carry out mathematical proofs? In answering these questions, this textbook explores the capabilities and limitations of algorithms and proof methods in mathematics and computer science. The chapters are carefully organized, featuring complete proofs and numerous examples throughout. Beginning with motivating examples, the book goes on to present the syntax and semantics of first-order logic. After providing a sequent calculus for this logic, a Henkin-type proof of the completeness theorem is given. These introductory chapters prepare the reader for the advanced topics that follow, such as Gödel's Incompleteness Theorems, Trakhtenbrot's undecidability theorem, Lindström's theorems on the maximality of first-order logic, and results linking logic with automata theory. This new edition features many modernizations, as well as two additional important results: The decidability of Presburger arithmetic, and the decidability of the weak monadic theory of the successor function. Mathematical Logic is ideal for students beginning their studies in logic and the foundations of mathematics. Although the primary audience for this textbook will be graduate students or advanced undergraduates in mathematics or computer science, in fact the book has few formal prerequisites. It demands of the reader only mathematical maturity and experience with basic abstract structures, such as those encountered in discrete mathematics or algebra.},
author = {Ebbinghaus, Heinz-Dieter},
address = {Cham, Switzerland},
edition = {Third edition.},
isbn = {9783030738396},
keywords = {Logic, Symbolic and mathematical},
language = {eng},
publisher = {Springer},
series = {Graduate texts in mathematics},
title = {Mathematical logic},
year = {2021},
}
@inbook{2012benari,
author = {Ben-Ari, M.},
address = {London},
edition = {3rd ed.},
isbn = {9781447141297},
keywords = {Logic, Symbolic and mathematical},
language = {eng},
publisher = {Springer},
title = {Mathematical logic for computer science},
year = {2012},
chapter={7},
}
@inproceedings{Dreben1979TheDP,
  title={The decision problem: Solvable classes of quantificational formulas},
  author={Burton Dreben and Warren D. Goldfarb},
  year={1979}
}
@article{lewis1980complexity,
  title={{Complexity results for classes of quantificational formulas}},
  author={Lewis, Harry R},
  journal={Journal of Computer and System Sciences},
  volume={21},
  number={3},
  pages={317--353},
  year={1980},
  publisher={Elsevier}
}
@techreport{demoura2008deciding,
author = {de Moura, Leonardo and Piskac, Ruzica and Bjørner, Nikolaj},
title = {{Deciding Effectively Propositional Logic using DPLL and Substitution Sets}},
year = {2008},
month = {August},
abstract = {We introduce a DPLL calculus that is a decision procedure for the Bernays-Schoenfinkel class, also known as EPR. Our calculus allows combining techniques for efficient propositional search with data-structures, such as Binary Decision Diagrams, that can efficiently and succinctly encode finite sets of substitutions and operations on these. In the calculus, clauses comprise of a sequence of literals together with a finite set of substitutions; truth assignments are also represented using substitution sets. The calculus works directly at the level of sets, and admits performing simultaneous constraint propagation and decisions, resulting in potentially exponential speedups over existing approaches.},
publisher = {Springer-Verlag},
url = {https://www.microsoft.com/en-us/research/publication/deciding-effectively-propositional-logic-using-dpll-and-substitution-sets/},
pages = {21},
number = {MSR-TR-2008-104},
}
@InProceedings{2016merzmanysorted,
author="Merz, Stephan
and Vanzetto, Hern{\'a}n",
editor="Butler, Michael
and Schewe, Klaus-Dieter
and Mashkoor, Atif
and Biro, Miklos",
title="Encoding TLA+ into Many-Sorted First-Order Logic",
booktitle="Abstract State Machines, Alloy, B, TLA, VDM, and Z",
year="2016",
publisher="Springer International Publishing",
address="Cham",
pages="54--69",
isbn="978-3-319-33600-8"
}
@InProceedings{2007decidablefragmentsmanysorted,
author="Abadi, Aharon
and Rabinovich, Alexander
and Sagiv, Mooly",
editor="Dershowitz, Nachum
and Voronkov, Andrei",
title="Decidable Fragments of Many-Sorted Logic",
booktitle="Logic for Programming, Artificial Intelligence, and Reasoning",
year="2007",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="17--31",
abstract="We investigate the possibility of developing a decidable logic which allows expressing a large variety of real world specifications. The idea is to define a decidable subset of many-sorted (typed) first- order logic. The motivation is that types simplify the complexity of mixed quantifiers when they quantify over different types. We noticed that many real world verification problems can be formalized by quantifying over different types in such a way that the relations between types remain simple.",
isbn="978-3-540-75560-9"
}
@InProceedings{2020ivymultimodal,
author="McMillan, Kenneth L.
and Padon, Oded",
editor="Lahiri, Shuvendu K.
and Wang, Chao",
title="Ivy: A Multi-modal Verification Tool for Distributed Algorithms",
booktitle="Computer Aided Verification",
year="2020",
publisher="Springer International Publishing",
address="Cham",
pages="190--202",
abstract="Ivy is a multi-modal verification tool for correct design and implementation of distributed protocols and algorithms, supporting modular specification, implementation and proof. Ivy supports proving safety and liveness properties of parameterized and infinite-state systems via three modes: deductive verification using an SMT solver, abstraction and model checking, and manual proofs using natural deduction. It supports light-weight formal methods via compositional specification-based testing and bounded model checking. Ivy can extract executable distributed programs by translation to efficient C++ code. It is designed to support decidable automated reasoning, to improve proof stability and to provide transparency in the case of proof failures. For this purpose, it presents concrete finite counterexamples, automatically audits proofs for decidability of verification conditions, and provides modular hiding of theories.",
isbn="978-3-030-53291-8"
}
@InProceedings{2009completeinstant,
author="Ge, Yeting
and de Moura, Leonardo",
editor="Bouajjani, Ahmed
and Maler, Oded",
title="Complete Instantiation for Quantified Formulas in Satisfiabiliby Modulo Theories",
booktitle="Computer Aided Verification",
year="2009",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="306--320",
abstract="Quantifier reasoning in Satisfiability Modulo Theories (SMT) is a long-standing challenge. The practical method employed in modern SMT solvers is to instantiate quantified formulas based on heuristics, which is not refutationally complete even for pure first-order logic. We present several decidable fragments of first order logic modulo theories. We show how to construct models for satisfiable formulas in these fragments. For richer undecidable fragments, we discuss conditions under which our procedure is refutationally complete. We also describe useful heuristics based on model checking for prioritizing or avoiding instantiations.",
isbn="978-3-642-02658-4"
}
@misc{2014manysortedlogic,
title="Many-sorted logic",
author="Jouko Vaananen",
year="2014",
url={http://www.math.helsinki.fi/logic/opetus/msl/ILLC_MSL_2014.1.pdf},
howpublished={\url{http://www.math.helsinki.fi/logic/opetus/msl/ILLC_MSL_2014.1.pdf}},
}
@article{1986kozen,
author = {Apt, K R and Kozen, D C},
title = {Limits for Automatic Verification of Finite-State Concurrent Systems},
year = {1986},
issue_date = {May 30,1986},
publisher = {Elsevier North-Holland, Inc.},
address = {USA},
volume = {22},
number = {6},
issn = {0020-0190},
url = {https://doi.org/10.1016/0020-0190(86)90071-2},
doi = {10.1016/0020-0190(86)90071-2},
journal = {Inf. Process. Lett.},
month = {may},
pages = {307–309},
numpages = {3}
}
@article{1997clarkenetwork,
author = {Clarke, E. M. and Grumberg, O. and Jha, S.},
title = {Verifying Parameterized Networks},
year = {1997},
issue_date = {Sept. 1997},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {19},
number = {5},
issn = {0164-0925},
url = {https://doi.org/10.1145/265943.265960},
doi = {10.1145/265943.265960},
abstract = {This article describes a technique based on network grammars and abstraction to verify families of state-transition systems. The family of state-transition systems is represented by a context-free network grammar. Using the structure of the network grammar our technique constructs a process invariant that simulates all the state-transition systems in the family. A novel idea introduced in this article is the use of regular languages to express state properties. We have implemented our techniques and verified two nontrivial examples.},
journal = {ACM Trans. Program. Lang. Syst.},
month = {sep},
pages = {726–750},
numpages = {25},
keywords = {parameterized systems, temporal logic, model checking, process invariants}
}
@book{libkin2004elements,
  title={Elements of finite model theory},
  author={Libkin, Leonid},
  volume={41},
  year={2004},
  publisher={Springer}
}
@Inbook{Kroening2016,
author="Kroening, Daniel
and Strichman, Ofer",
title="Quantified Formulas",
bookTitle="Decision Procedures: An Algorithmic Point of View",
year="2016",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="199--227",
abstract="Quantification allows us to specify the extent of validity of a predicate, the domain in which the predicate should hold. The syntactic element used in the logic for specifying quantification is called a quantifier.",
isbn="978-3-662-50497-0",
doi="10.1007/978-3-662-50497-0_9",
url="https://doi.org/10.1007/978-3-662-50497-0_9"
}
@inproceedings{1977cousot,
author = {Cousot, Patrick and Cousot, Radhia},
title = {Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints},
year = {1977},
isbn = {9781450373500},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/512950.512973},
doi = {10.1145/512950.512973},
abstract = {A program denotes computations in some universe of objects. Abstract interpretation of programs consists in using that denotation to describe computations in another universe of abstract objects, so that the results of abstract execution give some information on the actual computations. An intuitive example (which we borrow from Sintzoff [72]) is the rule of signs. The text -1515 * 17 may be understood to denote computations on the abstract universe {(+), (-), (±)} where the semantics of arithmetic operators is defined by the rule of signs. The abstract execution -1515 * 17 → -(+) * (+) → (-) * (+) → (-), proves that -1515 * 17 is a negative number. Abstract interpretation is concerned by a particular underlying structure of the usual universe of computations (the sign, in our example). It gives a summary of some facets of the actual executions of a program. In general this summary is simple to obtain but inaccurate (e.g. -1515 + 17 → -(+) + (+) → (-) + (+) → (±)). Despite its fundamentally incomplete results abstract interpretation allows the programmer or the compiler to answer questions which do not need full knowledge of program executions or which tolerate an imprecise answer, (e.g. partial correctness proofs of programs ignoring the termination problems, type checking, program optimizations which are not carried in the absence of certainty about their feasibility, …).},
booktitle = {Proceedings of the 4th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
pages = {238–252},
numpages = {15},
location = {Los Angeles, California},
series = {POPL '77}
}

@Inbook{Dams2018,
author="Dams, Dennis
and Grumberg, Orna",
editor="Clarke, Edmund M.
and Henzinger, Thomas A.
and Veith, Helmut
and Bloem, Roderick",
title="Abstraction and Abstraction Refinement",
bookTitle="Handbook of Model Checking",
year="2018",
publisher="Springer International Publishing",
address="Cham",
pages="385--419",
abstract="Abstraction, in the context of model checking, is aimed at reducing the state space of the system by omitting details that are irrelevant to the property being verified. Many successful approaches to the ``state explosion problem,'' some of them described in other chapters, can be seen as abstractions. In this chapter, several notions of abstraction are considered in a uniform setting. Different such notions lead to a variety of preservation results that establish which kind of temporal properties may be verified via an abstracted system. We first define the needed background on simulation and bisimulation relations and their logic preservation. We then present the abstraction that is currently most widely used in practice: existential abstraction, which preserves universal fragments of branching-time logics. We give examples of such abstractions: localization reduction for hardware and predicate abstraction for software. We then proceed to stronger abstractions which preserve full branching-time logics. We introduce Kripke Modal Transition Systems and modal simulation, and show logic preservation. We close the chapter with a review of the presented results in the light of the notion of completeness.",
isbn="978-3-319-10575-8",
doi="10.1007/978-3-319-10575-8_13",
url="https://doi.org/10.1007/978-3-319-10575-8_13"
}
@Inbook{Clarke2018ch1,
author="Clarke, Edmund M.
and Henzinger, Thomas A.
and Veith, Helmut",
editor="Clarke, Edmund M.
and Henzinger, Thomas A.
and Veith, Helmut
and Bloem, Roderick",
title="Introduction to Model Checking",
bookTitle="Handbook of Model Checking",
year="2018",
publisher="Springer International Publishing",
address="Cham",
pages="1--26",
abstract="Model checking is a computer-assisted method for the analysis of dynamical systems that can be modeled by state-transition systems. Drawing from research traditions in mathematical logic, programming languages, hardware design, and theoretical computer science, model checking is now widely used for the verification of hardware and software in industry. This chapter is an introduction and short survey of model checking. The chapter aims to motivate and link the individual chapters of the handbook, and to provide context for readers who are not familiar with model checking.",
isbn="978-3-319-10575-8",
doi="10.1007/978-3-319-10575-8_1",
url="https://doi.org/10.1007/978-3-319-10575-8_1"
}

@inproceedings{2003abswithoutcex,
author = {McMillan, Kenneth L. and Amla, Nina},
title = {Automatic Abstraction without Counterexamples},
year = {2003},
isbn = {3540008985},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {A method of automatic abstraction is presented that uses proofs of unsatisfiability derived from SAT-based bounded model checking as a guide to choosing an abstraction for unbounded model checking. Unlike earlier methods, this approach is not based on analysis of abstract counterexamples. The performance of this approach on benchmarks derived from microprocessor verification indicates that SAT solvers are quite effective in eliminating logic that is not relevant to a given property. Moreover, benchmark results suggest that when bounded model checking successfully terminates, and the problem is unsatisfiable, the number of state variables in the proof of unsatisfiability tends to be small. In almost all cases tested, when bounded model checking succeeded, unbounded model checking of the resulting abstraction also succeeded.},
booktitle = {Proceedings of the 9th International Conference on Tools and Algorithms for the Construction and Analysis of Systems},
pages = {2–17},
numpages = {16},
location = {Warsaw, Poland},
series = {TACAS'03}
}
@article{94mcabs,
author = {Clarke, Edmund M. and Grumberg, Orna and Long, David E.},
title = {Model Checking and Abstraction},
year = {1994},
issue_date = {Sept. 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {5},
issn = {0164-0925},
url = {https://doi.org/10.1145/186025.186051},
doi = {10.1145/186025.186051},
abstract = {We describe a method for using abstraction to reduce the complexity of temporal-logic model checking. Using techniques similar to those involved in abstract interpretation, we construct an abstract model of a program without ever examining the corresponding unabstracted model. We show how this abstract model can be used to verify properties of the original program. We have implemented a system based on these techniques, and we demonstrate their practicality using a number of examples, including a program representing a pipelined ALU circuit with over 101300 states.},
journal = {ACM Trans. Program. Lang. Syst.},
month = {sep},
pages = {1512–1542},
numpages = {31},
keywords = {temporal logic, abstract interpretation, model checking, binary decision diagrams (BDDs)}
}
@InProceedings{2003satinterp,
author="McMillan, K. L.",
editor="Hunt, Warren A.
and Somenzi, Fabio",
title="Interpolation and SAT-Based Model Checking",
booktitle="Computer Aided Verification",
year="2003",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="1--13",
abstract="We consider a fully SAT-based method of unbounded symbolic model checking based on computing Craig interpolants. In benchmark studies using a set of large industrial circuit verification instances, this method is greatly more efficient than BDD-based symbolic model checking, and compares favorably to some recent SAT-based model checking methods on positive instances.",
isbn="978-3-540-45069-6"
}
@article{rumelhart1986learning,
  title={Learning representations by back-propagating errors},
  author={Rumelhart, David E and Hinton, Geoffrey E and Williams, Ronald J},
  journal={nature},
  volume={323},
  number={6088},
  pages={533--536},
  year={1986},
  publisher={Nature Publishing Group}
}
@book{graham1989concrete,
author = {Graham, Ronald L. and Knuth, Donald E. and Patashnik, Oren},
title = {{Concrete Mathematics: A Foundation for Computer Science}},
year = {1994},
isbn = {0201558025},
publisher = {Addison-Wesley Longman Publishing Co., Inc.},
address = {USA},
edition = {2nd},
abstract = {From the Publisher: This book introduces the mathematics that supports advanced computer programming and the analysis of algorithms. The primary aim of its well-known authors is to provide a solid and relevant base of mathematical skills - the skills needed to solve complex problems, to evaluate horrendous sums, and to discover subtle patterns in data. It is an indispensable text and reference not only for computer scientists - the authors themselves rely heavily on it! - but for serious users of mathematics in virtually every discipline. Concrete Mathematics is a blending of CONtinuous and disCRETE mathematics. "More concretely," the authors explain, "it is the controlled manipulation of mathematical formulas, using a collection of techniques for solving problems." The subject matter is primarily an expansion of the Mathematical Preliminaries section in Knuth's classic Art of Computer Programming, but the style of presentation is more leisurely, and individual topics are covered more deeply. Several new topics have been added, and the most significant ideas have been traced to their historical roots. The book includes more than 500 exercises, divided into six categories. Complete answers are provided for all exercises, except research problems, making the book particularly valuable for self-study. Major topics include: Sums Recurrences Integer functions Elementary number theory Binomial coefficients Generating functions Discrete probability Asymptotic methods This second edition includes important new material about mechanical summation. In response to the widespread use ofthe first edition as a reference book, the bibliography and index have also been expanded, and additional nontrivial improvements can be found on almost every page. Readers will appreciate the informal style of Concrete Mathematics. Particularly enjoyable are the marginal graffiti contributed by students who have taken courses based on this material. The authors want to convey not only the importance of the techniques presented, but some of the fun in learning and using them.}
}
@incollection{Doerr_2019,
	doi = {10.1007/978-3-030-29414-4_1},
	url = {https://doi.org/10.1007%2F978-3-030-29414-4_1},
	year = 2019,
	month = {nov},
	publisher = {Springer International Publishing},
	pages = {1--87},
	author = {Benjamin Doerr},
	title = {Probabilistic Tools for the Analysis of Randomized Optimization Heuristics},
	booktitle = {Natural Computing Series}
}
@book{2011fourthcomporgdesign,
author = {Patterson, David A. and Hennessy, John L.},
title = {Computer Organization and Design, Revised Fourth Edition, Fourth Edition: The Hardware/Software Interface},
year = {2011},
isbn = {0123747503},
publisher = {Morgan Kaufmann Publishers Inc.},
address = {San Francisco, CA, USA},
edition = {4th},
abstract = {This Fourth Revised Edition of Computer Organization and Design includes a complete set of updated and new exercises, along with improvements and changes suggested by instructors and students. Focusing on the revolutionary change taking place in industry today--the switch from uniprocessor to multicore microprocessors--this classic textbook has a modern and up-to-date focus on parallelism in all its forms. Examples highlighting multicore and GPU processor designs are supported with performance and benchmarking data. As with previous editions, a MIPS processor is the core used to present the fundamentals of hardware technologies, assembly language, computer arithmetic, pipelining, memory hierarchies and I/O. Sections on the ARM and x86 architectures are also included.The companion CD provides a toolkit of simulators and compilers along with tutorials for using them, as well as advanced content for further study and a search utility for finding content on the CD and in the printed text. For the convenience of readers who have purchased an ebook edition or who may have misplaced the CD-ROM, all CD content is available as a download at bit.ly/nFXcLqThis Revised Fourth Edition of Computer Organization and Design has been updated with new exercises and improvements throughout suggested by instructors teaching from the bookCovers the revolutionary change from sequential to parallel computing, with a chapter on parallelism and sections in every chapter highlighting parallel hardware and software topicsIncludes an appendix by the Chief Scientist and the Director of Architecture of NVIDIA covering the emergence and importance of the modern GPU, describing in detail for the first time the highly parallel, highly multithreaded multiprocessor optimized for visual computing}
}
@article{manna1980deductive,
  title={A deductive approach to program synthesis},
  author={Manna, Zohar and Waldinger, Richard},
  journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume={2},
  number={1},
  pages={90--121},
  year={1980},
  publisher={ACM New York, NY, USA}
}
@InProceedings{1981clarkemerson,
author="Clarke, Edmund M.
and Emerson, E. Allen",
editor="Kozen, Dexter",
title="Design and synthesis of synchronization skeletons using branching time temporal logic",
booktitle="Logics of Programs",
year="1982",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="52--71",
abstract="We have shown that it is possible to automatically synthesize the synchronization skeleton of a concurrent program from a Temporal Logic specification. We believe that this approach may in the long run turn out to be quite practical. Since synchronization skeletons are, in general, quite small, the potentially exponential behavior of our algorithm need not be an insurmountable obstacle. Much additional research will be needed, however, to make the approach feasible in practice.",
isbn="978-3-540-39047-3"
}
@article{1984mannawolper,
author = {Manna, Zohar and Wolper, Pierre},
title = {{Synthesis of Communicating Processes from Temporal Logic Specifications}},
year = {1984},
issue_date = {Jan. 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {1},
issn = {0164-0925},
url = {https://doi.org/10.1145/357233.357237},
doi = {10.1145/357233.357237},
journal = {ACM Trans. Program. Lang. Syst.},
month = {jan},
pages = {68–93},
numpages = {26}
}
@inproceedings{1981benari,
author = {Ben-Ari, Mordechai and Manna, Zohar and Pnueli, Amir},
title = {The Temporal Logic of Branching Time},
year = {1981},
isbn = {089791029X},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/567532.567551},
doi = {10.1145/567532.567551},
abstract = {A temporal language and system are presented which are based on branching time structure. By the introduction of symmetrically dual sets of temporal operators, it is possible to discuss properties which hold either along one path or along all paths. Consequently it is possible to express in this system all the properties that were previously expressible in linear time or branching time systems. We present an exponential decision procedure for satisfiability in the language based on tableaux methods, and a complete deduction system. As associated temporal semantics is illustrated for both structured and graph representation of programs.},
booktitle = {Proceedings of the 8th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {164–176},
numpages = {13},
location = {Williamsburg, Virginia},
series = {POPL '81}
}
@article{2001attie,
author = {Attie, Paul C. and Emerson, E. Allen},
title = {Synthesis of Concurrent Programs for an Atomic Read/Write Model of Computation},
year = {2001},
issue_date = {March 2001},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {2},
issn = {0164-0925},
url = {https://doi.org/10.1145/383043.383044},
doi = {10.1145/383043.383044},
abstract = {Methods for mechanically synthesizing concurrent programs for temporal logic specifications have been proposed by Emerson and Clarke and by Manna and Wolper. An important advantage of these synthesis methods is that they obviate the need to manually compose a program and manually construct a proof of its correctness. A serious drawback of these methods in practice, however, is that they produce concurrent programs for models of computation that are often unrealistic, involving highly centralized system architecture (Manna and Wolper), processes with global information about the system state (Emerson and Clarke), or reactive modules that can read all of their inputs in one atomic step (Anuchitanukul and Manna, and Pnueli and Rosner). Even simple synchronization protocols based on atomic read/write primitives such as Peterson's solution to the mutual exclusion problem have remained outside the scope of practical mechanical synthesis methods. In this paper, we show how to mechanically synthesize in more realistic computational models solutions to synchronization problems. We illustrate the method by synthesizing Peterson's solution to the mutual exclusion problem.},
journal = {ACM Trans. Program. Lang. Syst.},
month = {mar},
pages = {187–242},
numpages = {56},
keywords = {program synthesis, temporal logic, atomic registers, specification, concurrent programs}
}
@article{1986clarkeemerson,
author = {Clarke, E. M. and Emerson, E. A. and Sistla, A. P.},
title = {Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications},
year = {1986},
issue_date = {April 1986},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {2},
issn = {0164-0925},
url = {https://doi.org/10.1145/5397.5399},
doi = {10.1145/5397.5399},
abstract = {We give an efficient procedure for verifying that a finite-state concurrent system meets a specification expressed in a (propositional, branching-time) temporal logic. Our algorithm has complexity linear in both the size of the specification and the size of the global state graph for the concurrent system. We also show how this approach can be adapted to handle fairness. We argue that our technique can provide a practical alternative to manual proof construction or use of a mechanical theorem prover for verifying many finite-state concurrent systems. Experimental results show that state machines with several hundred states can be checked in a matter of seconds.},
journal = {ACM Trans. Program. Lang. Syst.},
month = {apr},
pages = {244–263},
numpages = {20}
}
@inproceedings{1983wolpervardi,
author = {Wolper, Pierre and Vardi, Moshe Y. and Sistla, A. Prasad},
title = {Reasoning about Infinite Computation Paths},
year = {1983},
isbn = {0818605081},
publisher = {IEEE Computer Society},
address = {USA},
url = {https://doi.org/10.1109/SFCS.1983.51},
doi = {10.1109/SFCS.1983.51},
abstract = {We investigate extensions of temporal logic by finite automata on infinite words. There are three different types of acceptance conditions (finite, looping and repeating) that one can give for these finite automata. This gives rise to three different logics. It turns out, however. that these logics have the same expressive power but differ in the complexity of their decision problem. We also investigate the addition of alternation and show that it does not increase the complexity of the decision problem.},
booktitle = {Proceedings of the 24th Annual Symposium on Foundations of Computer Science},
pages = {185–194},
numpages = {10},
series = {SFCS '83}
}
@inproceedings{1985pnuelilich,
author = {Lichtenstein, Orna and Pnueli, Amir},
title = {Checking That Finite State Concurrent Programs Satisfy Their Linear Specification},
year = {1985},
isbn = {0897911474},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/318593.318622},
doi = {10.1145/318593.318622},
abstract = {We present an algorithm for checking satisfiability of a linear time temporal logic formula over a finite state concurrent program. The running time of the algorithm is exponential in the size of the formula but linear in the size of the checked program. The algorithm yields also a formal proof in case the formula is valid over the program. The algorithm has four versions that check satisfiability by unrestricted, impartial, just and fair computations of the given program.},
booktitle = {Proceedings of the 12th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
pages = {97–107},
numpages = {11},
location = {New Orleans, Louisiana, USA},
series = {POPL '85}
}
@article{BIERE2002160,
title = {Liveness Checking as Safety Checking},
journal = {Electronic Notes in Theoretical Computer Science},
volume = {66},
number = {2},
pages = {160-177},
year = {2002},
note = {FMICS'02, 7th International ERCIM Workshop in Formal Methods for Industrial Critical Systems (ICALP 2002 Satellite Workshop)},
issn = {1571-0661},
doi = {https://doi.org/10.1016/S1571-0661(04)80410-9},
url = {https://www.sciencedirect.com/science/article/pii/S1571066104804109},
author = {Armin Biere and Cyrille Artho and Viktor Schuppan},
abstract = {Temporal logic is widely used for specifying hardware and software systems. Typically two types of properties are distinguished, safety and liveness properties. While safety can easily be checked by reachability analysis, and many efficient checkers for safety properties exist, more sophisticated algorithms have always been considered to be necessary for checking liveness. In this paper we describe an efficient translation of liveness checking problems into safety checking problems. A counter example is detected by saving a previously visited state in an additional state recording component and checking a loop closing condition. The approach handles fairness and thus extends to full LTL.}
}
@article{1985sistlaclarke,
author = {Sistla, A. P. and Clarke, E. M.},
title = {The Complexity of Propositional Linear Temporal Logics},
year = {1985},
issue_date = {July 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {32},
number = {3},
issn = {0004-5411},
url = {https://doi.org/10.1145/3828.3837},
doi = {10.1145/3828.3837},
abstract = {The complexity of satisfiability and determination of truth in a particular finite structure are considered for different propositional linear temporal logics. It is shown that these problems are NP-complete for the logic with F and are PSPACE-complete for the logics with F, X, with U, with U, S, X operators and for the extended logic with regular operators given by Wolper.},
journal = {J. ACM},
month = {jul},
pages = {733–749},
numpages = {17}
}
@inproceedings{1999castropbft,
author = {Castro, Miguel and Liskov, Barbara},
title = {Practical Byzantine Fault Tolerance},
year = {1999},
isbn = {1880446391},
publisher = {USENIX Association},
address = {USA},
booktitle = {Proceedings of the Third Symposium on Operating Systems Design and Implementation},
pages = {173–186},
numpages = {14},
location = {New Orleans, Louisiana, USA},
series = {OSDI '99}
}
@inproceedings{2011lamport,
author = {Lamport, Leslie},
title = {Byzantizing Paxos by Refinement},
year = {2011},
isbn = {9783642240997},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {We derive a 3f +1 process Byzantine Paxos consensus algorithm by Byzantizing a variant of the ordinary Paxos algorithm--that is, by having 2f+1 nonfaulty processes emulate the ordinary Paxos algorithm despite the presence of f malicious processes. We have written a formal, machine-checked proof that the Byzantized algorithm implements the ordinary Paxos consensus algorithm under a suitable refinement mapping.},
booktitle = {Proceedings of the 25th International Conference on Distributed Computing},
pages = {211–224},
numpages = {14},
location = {Rome, Italy},
series = {DISC'11}
}
@article{1978rivestcrypto,
author = {Rivest, R. L. and Shamir, A. and Adleman, L.},
title = {A Method for Obtaining Digital Signatures and Public-Key Cryptosystems},
year = {1978},
issue_date = {Feb. 1978},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {21},
number = {2},
issn = {0001-0782},
url = {https://doi.org/10.1145/359340.359342},
doi = {10.1145/359340.359342},
abstract = {An encryption method is presented with the novel property that publicly revealing an encryption key does not thereby reveal the corresponding decryption key. This has two important consequences: (1) Couriers or other secure means are not needed to transmit keys, since a message can be enciphered using an encryption key publicly revealed by the intented recipient. Only he can decipher the message, since only he knows the corresponding decryption key. (2) A message can be “signed” using a privately held decryption key. Anyone can verify this signature using the corresponding publicly revealed encryption key. Signatures cannot be forged, and a signer cannot later deny the validity of his signature. This has obvious applications in “electronic mail” and “electronic funds transfer” systems. A message is encrypted by representing it as a number M, raising M to a publicly specified power e, and then taking the remainder when the result is divided by the publicly specified product, n, of two large secret primer numbers p and q. Decryption is similar; only a different, secret, power d is used, where e * d ≡ 1(mod (p - 1) * (q - 1)). The security of the system rests in part on the difficulty of factoring the published divisor, n.},
journal = {Commun. ACM},
month = {feb},
pages = {120–126},
numpages = {7},
keywords = {authentication, factorization, cryptography, electronic mail, public-key cryptosystems, privacy, message-passing, security, electronic funds transfer, digital signatures, prime number}
}
@article{1982lamportshostak,
author = {Lamport, Leslie and Shostak, Robert and Pease, Marshall},
title = {{The Byzantine Generals Problem}},
year = {1982},
issue_date = {July 1982},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {3},
issn = {0164-0925},
url = {https://doi.org/10.1145/357172.357176},
doi = {10.1145/357172.357176},
journal = {ACM Trans. Program. Lang. Syst.},
month = {jul},
pages = {382–401},
numpages = {20}
}
@article{1980peasereaching,
author = {Pease, M. and Shostak, R. and Lamport, L.},
title = {Reaching Agreement in the Presence of Faults},
year = {1980},
issue_date = {April 1980},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {27},
number = {2},
issn = {0004-5411},
url = {https://doi.org/10.1145/322186.322188},
doi = {10.1145/322186.322188},
abstract = {The problem addressed here concerns a set of isolated processors, some unknown subset of which may be faulty, that communicate only by means of two-party messages. Each nonfaulty processor has a private value of information that must be communicated to each other nonfaulty processor. Nonfaulty processors always communicate honestly, whereas faulty processors may lie. The problem is to devise an algorithm in which processors communicate their own values and relay values received from others that allows each nonfaulty processor to infer a value for each other processor. The value inferred for a nonfaulty processor must be that processor's private value, and the value inferred for a faulty one must be consistent with the corresponding value inferred by each other nonfaulty processor.It is shown that the problem is solvable for, and only for, n ≥ 3m + 1, where m is the number of faulty processors and n is the total number. It is also shown that if faulty processors can refuse to pass on information but cannot falsely relay information, the problem is solvable for arbitrary n ≥ m ≥ 0. This weaker assumption can be approximated in practice using cryptographic methods.},
journal = {J. ACM},
month = {apr},
pages = {228–234},
numpages = {7}
}
@ARTICLE{1978sift,  
author={Wensley, J.H. and Lamport, L. and Goldberg, J. and Green, M.W. and Levitt, K.N. and Melliar-Smith, P.M. and Shostak, R.E. and Weinstock, C.B.},  
journal={Proceedings of the IEEE},   
title={SIFT: Design and analysis of a fault-tolerant computer for aircraft control},   
year={1978},  
volume={66},  
number={10},  
pages={1240-1255},  
doi={10.1109/PROC.1978.11114}}
@inproceedings{2018abrahamsyncbyz,
author = {Abraham, Ittai and Devadas, Srinivas and Dolev, Danny and Nayak, Kartik and Ren, Ling},
title = {Synchronous Byzantine Agreement with Expected O(1) Rounds, Expected Communication, and Optimal Resilience},
year = {2019},
isbn = {978-3-030-32100-0},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-030-32101-7_20},
doi = {10.1007/978-3-030-32101-7_20},
abstract = {We present new protocols for Byzantine agreement in the synchronous and authenticated setting, tolerating the optimal number of f faults among parties. Our protocols achieve an expected O(1) round complexity and an expected communication complexity. The exact round complexity in expectation is 10 for a static adversary and 16 for a strongly rushing adaptive adversary. For comparison, previous protocols in the same setting require expected 29 rounds.},
booktitle = {Financial Cryptography and Data Security: 23rd International Conference, FC 2019, Frigate Bay, St. Kitts and Nevis, February 18–22, 2019, Revised Selected Papers},
pages = {320–334},
numpages = {15},
location = {St. Kitts, Saint Kitts and Nevis}
}
@book{2008principlemc,
author = {Baier, Christel and Katoen, Joost-Pieter},
year = {2008},
month = {01},
pages = {},
title = {Principles of Model Checking},
volume = {26202649},
isbn = {978-0-262-02649-9}
}
@inproceedings{1969waldingersynthprow,
author = {Waldinger, Richard J. and Lee, Richard C. T.},
title = {PROW: A Step toward Automatic Program Writing},
year = {1969},
publisher = {Morgan Kaufmann Publishers Inc.},
address = {San Francisco, CA, USA},
abstract = {This paper Describes a program, called "PROW", which writes programs PROW accepts the specification of the program in the language of predicate calculus, decides the algorithm for the program and then produces a LISP program which is an implementation of the algorithm. Since the construction of the algorithm is obtained by formal theorem-proving techniques, the programs that PROW writes are free from logical errors and do not have to be debugged The user of PROW can make PROW write programs in languages other than LISP by modifying the part of PROW that translates an algorithm to a LISP program. Thus PROW can be modified to write programs in any language In the end of this paper, it is shown that PROW can also be used as a question-answering program},
booktitle = {Proceedings of the 1st International Joint Conference on Artificial Intelligence},
pages = {241–252},
numpages = {12},
location = {Washington, DC},
series = {IJCAI'69}
}
@inproceedings{1989pnuelirosner,
author = {Pnueli, A. and Rosner, R.},
title = {On the Synthesis of a Reactive Module},
year = {1989},
isbn = {0897912942},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/75277.75293},
doi = {10.1145/75277.75293},
abstract = {We consider the synthesis of a reactive module with input x and output y, which is specified by the linear temporal formula @@@@(x, y). We show that there exists a program satisfying @@@@ iff the branching time formula (∀x) (∃y) A@@@@(x, y) is valid over all tree models. For the restricted case that all variables range over finite domains, the validity problem is decidable, and we present an algorithm for constructing the program whenever it exists. The algorithm is based on a new procedure for checking the emptiness of Rabin automata on infinite trees in time exponential in the number of pairs, but only polynomial in the number of states. This leads to a synthesis algorithm whose complexity is double exponential in the length of the given specification.},
booktitle = {Proceedings of the 16th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {179–190},
numpages = {12},
location = {Austin, Texas, USA},
series = {POPL '89}
}
@article{1975dijkstrawp,
author = {Dijkstra, Edsger W.},
title = {Guarded Commands, Nondeterminacy and Formal Derivation of Programs},
year = {1975},
issue_date = {Aug. 1975},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {18},
number = {8},
issn = {0001-0782},
url = {https://doi.org/10.1145/360933.360975},
doi = {10.1145/360933.360975},
abstract = {So-called “guarded commands” are introduced as a building block for alternative and repetitive constructs that allow nondeterministic program components for which at least the activity evoked, but possibly even the final state, is not necessarily uniquely determined by the initial state. For the formal derivation of programs expressed in terms of these constructs, a calculus will be be shown.},
journal = {Commun. ACM},
month = {aug},
pages = {453–457},
numpages = {5},
keywords = {sequencing primitives, correctness proof, programming languages, program semantics, derivation of programs, programming methodology, termination, repetition, nondeterminancy, case-construction, programming language semantics}
}
@article{1991waitfreesync,
author = {Herlihy, Maurice},
title = {Wait-Free Synchronization},
year = {1991},
issue_date = {Jan. 1991},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {13},
number = {1},
issn = {0164-0925},
url = {https://doi.org/10.1145/114005.102808},
doi = {10.1145/114005.102808},
abstract = {A wait-free implementation of a concurrent data object is one that guarantees that any process can complete any operation in a finite number of steps, regardless of the execution speeds of the other processes. The problem of constructing a wait-free implementation of one data object from another lies at the heart of much recent work in concurrent algorithms, concurrent data structures, and multiprocessor architectures. First, we introduce a simple and general technique, based on reduction to a concensus protocol, for proving statements of the form, “there is no wait-free implementation of X by Y.” We derive a hierarchy of objects such that no object at one level has a wait-free implementation in terms of objects at lower levels. In particular, we show that atomic read/write registers, which have been the focus of much recent attention, are at the bottom of the hierarchy: thay cannot be used to construct wait-free implementations of many simple and familiar data types. Moreover, classical synchronization primitives such astest\&set and fetch\&add, while more powerful than read and write, are also computationally weak, as are the standard message-passing primitives. Second, nevertheless, we show that there do exist simple universal objects from which one can construct a wait-free implementation of any sequential object.},
journal = {ACM Trans. Program. Lang. Syst.},
month = {jan},
pages = {124–149},
numpages = {26},
keywords = {linearization, wait-free synchronization}
}
@article{1990aspnesherlihy,
author = {Aspnes, James and Herlihy, M.},
title = {Fast Randomized Consensus Using Shared Memory},
year = {1990},
issue_date = {Sep. 1990},
publisher = {Academic Press, Inc.},
address = {USA},
volume = {11},
number = {3},
issn = {0196-6774},
url = {https://doi.org/10.1016/0196-6774(90)90021-6},
doi = {10.1016/0196-6774(90)90021-6},
journal = {J. Algorithms},
month = {sep},
pages = {441–461},
numpages = {21}
}