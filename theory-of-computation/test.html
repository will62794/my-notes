<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="William Schultz" />
  <meta name="author" content="William Schultz" />
  <title>Notes on Theory of Computation</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../pandoc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Notes on Theory of Computation</h1>
<p class="author">William Schultz</p>
<p class="author">William Schultz</p>
</header>
<p>In standard computation/complexity theory, we study <em>decision problems</em>. That is, computational problems that have a <em>yes/no</em> answer. These types of problems can be formulated in terms of a corresponding <em>language</em>, which is a set of strings <span class="math inline"><em>w</em> ∈ <em>Σ</em><sup>*</sup></span>, where <span class="math inline"><em>Σ</em></span> is some finite alphabet i.e. some finite set of symbols.</p>
<h1 id="decidability">Decidability</h1>
<p>We say that a language is <em>decidable</em> if there exists a Turing machine <span class="math inline"><em>M</em></span> such that <span class="math inline"><em>M</em></span> accepts every input <span class="math inline"><em>w</em> ∈ <em>L</em></span> and always halts. We say that a language is <em>recognizable</em> if there is a Turing machine <span class="math inline"><em>M</em></span> that accepts every input <span class="math inline"><em>w</em> ∈ <em>L</em></span> but it may reject or loop forever on inputs <span class="math inline"><em>w</em> ∉ <em>L</em></span>. Note that for any Turing machine on a given input, there are three possible outcomes: (1) <em>accept</em>, (2) <em>reject</em>, or (3) <em>loop forever</em>. A basic undecidable problem is the <span class="math inline"><em>A</em><sub><em>T</em><em>M</em></sub></span> problem, which asks, given a Turing machine <span class="math inline"><em>M</em></span> and input <span class="math inline"><em>w</em></span>, does machine <span class="math inline"><em>M</em></span> accept on <span class="math inline"><em>w</em></span>? Note that the class of recognizable languages is more general than the class of undecidable languages. That is, any language that is decidable is recognizable, but the converse is not necessarily true. Decidability is in some sense the coarsest possible notion of complexity i.e. it is only concerned with whether there exists any general algorithm for solving a problem, regardless of how fast/slow it is. Undeciable problems are, in some sense, outside the realm of what can be computed by a single, generic algorithm i.e. one that successfully terminates on all possible inputs.</p>
<h1 id="p-and-np">P and NP</h1>
<p>The class <span class="math inline"><em>P</em></span> is the set of languages for which there exists a Turing machine (i.e. an algorithm) that can decide <span class="math inline"><em>P</em></span> in polynomial time <span class="math inline"><em>O</em>(<em>n</em><sup><em>k</em></sup>)</span>, for some positive constant <span class="math inline"><em>k</em></span>. The class <span class="math inline"><em>N</em><em>P</em></span> is defined as the set of languages for which there exists a polynomial time <em>verifier</em>. Formally, a language <span class="math inline"><em>L</em></span> is in <span class="math inline"><em>N</em><em>P</em></span> if there exists a Turing machine <span class="math inline"><em>V</em></span> (a verifier) such that, for any input <span class="math inline"><em>w</em> ∈ <em>L</em></span> there exists a certificate <span class="math inline"><em>c</em></span> such that <span class="math inline"><em>V</em></span> accepts <span class="math inline">⟨<em>w</em>, <em>c</em>⟩</span> and runs in polynomial time. Note that the size of the certificate can only be polynomial in the size of the input <span class="math inline"><em>w</em></span>, since the verifier machine only has a polynomial time run-time budget. At a high level, <span class="math inline"><em>N</em><em>P</em></span> is the class of languages for which there exists an efficient way to verify solutions to a given problem instance. There may not be an efficient algorithm to decide the answer to a given instance though. It is not known for certain, however, whether there are (or aren’t) polynomial time algorithms for solving problems in <span class="math inline"><em>N</em><em>P</em></span>. This is the famous <span class="math inline"><em>P</em></span> vs. <span class="math inline"><em>N</em><em>P</em></span> problem. It is believed that problems in <span class="math inline"><em>N</em><em>P</em></span> do not have efficient (polynomial time) algorithms, but this is not formally proven.</p>
<h2 id="np-completeness">NP-Completeness</h2>
<p>There are some problems in the class <span class="math inline"><em>N</em><em>P</em></span> that are the “hardest” problems in <span class="math inline"><em>N</em><em>P</em></span>. We call these problems <span class="math inline"><em>N</em><em>P</em></span>-complete. Formally, we say that a language <span class="math inline"><em>A</em></span> is <span class="math inline"><em>N</em><em>P</em></span>-complete if <span class="math inline"><em>A</em> ∈ <em>N</em><em>P</em></span> and every language <span class="math inline"><em>B</em> ∈ <em>N</em><em>P</em></span> is polynomial time reducible to <span class="math inline"><em>A</em></span>. For two languages <span class="math inline"><em>A</em></span> and <span class="math inline"><em>B</em></span>, we say that <span class="math inline"><em>A</em></span> is polynomial time reducible to <span class="math inline"><em>B</em></span> if there is a polynomial time converter <span class="math inline"><em>R</em><sub><em>A</em> → <em>B</em></sub></span> that converts an input <span class="math inline"><em>w</em><sub><em>A</em></sub></span> to an input <span class="math inline"><em>w</em><sub><em>B</em></sub> = <em>R</em><sub><em>A</em> → <em>B</em></sub>(<em>w</em><sub><em>A</em></sub>)</span> so that <span class="math inline"><em>w</em><sub><em>B</em></sub> ∈ <em>B</em> ⇔ <em>w</em><sub><em>A</em></sub> ∈ <em>A</em></span>. So, if a problem is <span class="math inline"><em>N</em><em>P</em></span>-complete, it means that every problem in <span class="math inline"><em>N</em><em>P</em></span> can be reduced to it i.e. we can take an input of any problem in <span class="math inline"><em>N</em><em>P</em></span>, convert it to an input for the NP-complete problem in a way that preserves correctness. So, this means that if we solve one <span class="math inline"><em>N</em><em>P</em></span> complete problem in an efficient (polynomial time) algorithm, then all <span class="math inline"><em>N</em><em>P</em></span> problems are efficiently solvable.</p>
<p>The canonical <span class="math inline"><em>N</em><em>P</em></span>-complete problem is the SAT problem i.e. checking whether a boolean formula is satisfiable. The Cook-Levin theorem shows that SAT is <span class="math inline"><em>N</em><em>P</em></span>-complete. With this knowledge, we can prove other problems <span class="math inline"><em>N</em><em>P</em></span>-complete. Since we know that any <span class="math inline"><em>B</em> ∈ <em>N</em><em>P</em></span> can be reduced to an <span class="math inline"><em>N</em><em>P</em></span>-complete problem <span class="math inline"><em>A</em></span>, we can show that <span class="math inline"><em>B</em></span> is <span class="math inline"><em>N</em><em>P</em></span>-complete by showing that <span class="math inline"><em>A</em></span> is reducible to <span class="math inline"><em>B</em></span>. That is, we establish that <span class="math inline"><em>A</em></span> is reducible to <span class="math inline"><em>B</em></span> and <span class="math inline"><em>B</em></span> is reducible to <span class="math inline"><em>A</em></span>, so the problems are “equivalently" hard. Note that there are some problems in <span class="math inline"><em>N</em><em>P</em></span>, however, that are not <span class="math inline"><em>N</em><em>P</em></span>-complete. Ladner’s theorem establishes this i.e. it proves the existence of problems that are in <span class="math inline"><em>N</em><em>P</em></span> but not in <span class="math inline"><em>P</em></span> and are not <span class="math inline"><em>N</em><em>P</em></span>-complete. This class is called <span class="math inline"><em>N</em><em>P</em></span>-intermediate. The construction used in this theorem is complicated, though, and not necessarily “natural”. There are problems that are suspected to be in <span class="math inline"><em>N</em><em>P</em></span>-intermediate i.e. they are in <span class="math inline"><em>N</em><em>P</em></span> but have not been shown to be in <span class="math inline"><em>P</em></span> or be <span class="math inline"><em>N</em><em>P</em></span>-complete e.g. integer factorization.</p>
<h2 id="np-vs.-nexp">NP vs. NEXP</h2>
<p>I believe that one straightforward way to characterize the difference between “polynomial" non-deterministic Turing machines (NP) and “exponential" non-deterministic Turing machines (NEXP) is to consider the maximum depth of the computation tree branches. In NP, we are allowed to use non-deterministic machines with paths of polynomial length, whereas in NEXP, we are allowed to use non-deterministic machines with exponentially long paths.</p>
<p>Note that we can also use the nondeterministic Turing machine perspective as an alternate way to view the difference between classes like <span class="math inline"><em>N</em><em>P</em></span> and <span class="math inline"><em>c</em><em>o</em><em>N</em><em>P</em></span>. <span class="math inline"><em>N</em><em>P</em></span> consists of problems that have some accepting path out of all branches on the nondeterministic computation, whereas problems in <span class="math inline"><em>c</em><em>o</em><em>N</em><em>P</em></span> are those for which all paths must accept. For example, satisfiability vs. unsatisfiability.</p>
</body>
</html>
